/*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/
module derelict.vulkan.types;
import derelict.vulkan.base;
import derelict.vulkan.system;

extern(System):

mixin(VK_DEFINE_HANDLE("VkInstance"));
mixin(VK_DEFINE_HANDLE("VkPhysicalDevice"));
mixin(VK_DEFINE_HANDLE("VkDevice"));
mixin(VK_DEFINE_HANDLE("VkQueue"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkSemaphore"));
mixin(VK_DEFINE_HANDLE("VkCommandBuffer"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkFence"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDeviceMemory"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkBuffer"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkImage"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkEvent"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkQueryPool"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkBufferView"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkImageView"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkShaderModule"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkPipelineCache"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkPipelineLayout"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkRenderPass"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkPipeline"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDescriptorSetLayout"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkSampler"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDescriptorPool"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDescriptorSet"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkFramebuffer"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkCommandPool"));

enum VkPipelineCacheHeaderVersion {
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
	VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
	VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
	VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (VK_PIPELINE_CACHE_HEADER_VERSION_ONE - VK_PIPELINE_CACHE_HEADER_VERSION_ONE + 1),
	VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
}

enum VkResult {
	VK_SUCCESS = 0,
	VK_NOT_READY = 1,
	VK_TIMEOUT = 2,
	VK_EVENT_SET = 3,
	VK_EVENT_RESET = 4,
	VK_INCOMPLETE = 5,
	VK_ERROR_OUT_OF_HOST_MEMORY = -1,
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
	VK_ERROR_INITIALIZATION_FAILED = -3,
	VK_ERROR_DEVICE_LOST = -4,
	VK_ERROR_MEMORY_MAP_FAILED = -5,
	VK_ERROR_LAYER_NOT_PRESENT = -6,
	VK_ERROR_EXTENSION_NOT_PRESENT = -7,
	VK_ERROR_FEATURE_NOT_PRESENT = -8,
	VK_ERROR_INCOMPATIBLE_DRIVER = -9,
	VK_ERROR_TOO_MANY_OBJECTS = -10,
	VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
	VK_ERROR_SURFACE_LOST_KHR = -1000000000,
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
	VK_SUBOPTIMAL_KHR = 1000001003,
	VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
	VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
	VK_RESULT_BEGIN_RANGE = VK_ERROR_FORMAT_NOT_SUPPORTED,
	VK_RESULT_END_RANGE = VK_INCOMPLETE,
	VK_RESULT_RANGE_SIZE = (VK_INCOMPLETE - VK_ERROR_FORMAT_NOT_SUPPORTED + 1),
	VK_RESULT_MAX_ENUM = 0x7FFFFFFF
}

enum VkStructureType {
	VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
	VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
	VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
	VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
	VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
	VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
	VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
	VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,
	VK_STRUCTURE_TYPE_BEGIN_RANGE = VK_STRUCTURE_TYPE_APPLICATION_INFO,
	VK_STRUCTURE_TYPE_END_RANGE = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
	VK_STRUCTURE_TYPE_RANGE_SIZE = (VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - VK_STRUCTURE_TYPE_APPLICATION_INFO + 1),
	VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkSystemAllocationScope {
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
	VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
	VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
	VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - VK_SYSTEM_ALLOCATION_SCOPE_COMMAND + 1),
	VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkInternalAllocationType {
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
	VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
	VK_INTERNAL_ALLOCATION_TYPE_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
	VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1),
	VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkFormat {
	VK_FORMAT_UNDEFINED = 0,
	VK_FORMAT_R4G4_UNORM_PACK8 = 1,
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
	VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
	VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
	VK_FORMAT_R8_UNORM = 9,
	VK_FORMAT_R8_SNORM = 10,
	VK_FORMAT_R8_USCALED = 11,
	VK_FORMAT_R8_SSCALED = 12,
	VK_FORMAT_R8_UINT = 13,
	VK_FORMAT_R8_SINT = 14,
	VK_FORMAT_R8_SRGB = 15,
	VK_FORMAT_R8G8_UNORM = 16,
	VK_FORMAT_R8G8_SNORM = 17,
	VK_FORMAT_R8G8_USCALED = 18,
	VK_FORMAT_R8G8_SSCALED = 19,
	VK_FORMAT_R8G8_UINT = 20,
	VK_FORMAT_R8G8_SINT = 21,
	VK_FORMAT_R8G8_SRGB = 22,
	VK_FORMAT_R8G8B8_UNORM = 23,
	VK_FORMAT_R8G8B8_SNORM = 24,
	VK_FORMAT_R8G8B8_USCALED = 25,
	VK_FORMAT_R8G8B8_SSCALED = 26,
	VK_FORMAT_R8G8B8_UINT = 27,
	VK_FORMAT_R8G8B8_SINT = 28,
	VK_FORMAT_R8G8B8_SRGB = 29,
	VK_FORMAT_B8G8R8_UNORM = 30,
	VK_FORMAT_B8G8R8_SNORM = 31,
	VK_FORMAT_B8G8R8_USCALED = 32,
	VK_FORMAT_B8G8R8_SSCALED = 33,
	VK_FORMAT_B8G8R8_UINT = 34,
	VK_FORMAT_B8G8R8_SINT = 35,
	VK_FORMAT_B8G8R8_SRGB = 36,
	VK_FORMAT_R8G8B8A8_UNORM = 37,
	VK_FORMAT_R8G8B8A8_SNORM = 38,
	VK_FORMAT_R8G8B8A8_USCALED = 39,
	VK_FORMAT_R8G8B8A8_SSCALED = 40,
	VK_FORMAT_R8G8B8A8_UINT = 41,
	VK_FORMAT_R8G8B8A8_SINT = 42,
	VK_FORMAT_R8G8B8A8_SRGB = 43,
	VK_FORMAT_B8G8R8A8_UNORM = 44,
	VK_FORMAT_B8G8R8A8_SNORM = 45,
	VK_FORMAT_B8G8R8A8_USCALED = 46,
	VK_FORMAT_B8G8R8A8_SSCALED = 47,
	VK_FORMAT_B8G8R8A8_UINT = 48,
	VK_FORMAT_B8G8R8A8_SINT = 49,
	VK_FORMAT_B8G8R8A8_SRGB = 50,
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
	VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
	VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
	VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
	VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
	VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
	VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
	VK_FORMAT_R16_UNORM = 70,
	VK_FORMAT_R16_SNORM = 71,
	VK_FORMAT_R16_USCALED = 72,
	VK_FORMAT_R16_SSCALED = 73,
	VK_FORMAT_R16_UINT = 74,
	VK_FORMAT_R16_SINT = 75,
	VK_FORMAT_R16_SFLOAT = 76,
	VK_FORMAT_R16G16_UNORM = 77,
	VK_FORMAT_R16G16_SNORM = 78,
	VK_FORMAT_R16G16_USCALED = 79,
	VK_FORMAT_R16G16_SSCALED = 80,
	VK_FORMAT_R16G16_UINT = 81,
	VK_FORMAT_R16G16_SINT = 82,
	VK_FORMAT_R16G16_SFLOAT = 83,
	VK_FORMAT_R16G16B16_UNORM = 84,
	VK_FORMAT_R16G16B16_SNORM = 85,
	VK_FORMAT_R16G16B16_USCALED = 86,
	VK_FORMAT_R16G16B16_SSCALED = 87,
	VK_FORMAT_R16G16B16_UINT = 88,
	VK_FORMAT_R16G16B16_SINT = 89,
	VK_FORMAT_R16G16B16_SFLOAT = 90,
	VK_FORMAT_R16G16B16A16_UNORM = 91,
	VK_FORMAT_R16G16B16A16_SNORM = 92,
	VK_FORMAT_R16G16B16A16_USCALED = 93,
	VK_FORMAT_R16G16B16A16_SSCALED = 94,
	VK_FORMAT_R16G16B16A16_UINT = 95,
	VK_FORMAT_R16G16B16A16_SINT = 96,
	VK_FORMAT_R16G16B16A16_SFLOAT = 97,
	VK_FORMAT_R32_UINT = 98,
	VK_FORMAT_R32_SINT = 99,
	VK_FORMAT_R32_SFLOAT = 100,
	VK_FORMAT_R32G32_UINT = 101,
	VK_FORMAT_R32G32_SINT = 102,
	VK_FORMAT_R32G32_SFLOAT = 103,
	VK_FORMAT_R32G32B32_UINT = 104,
	VK_FORMAT_R32G32B32_SINT = 105,
	VK_FORMAT_R32G32B32_SFLOAT = 106,
	VK_FORMAT_R32G32B32A32_UINT = 107,
	VK_FORMAT_R32G32B32A32_SINT = 108,
	VK_FORMAT_R32G32B32A32_SFLOAT = 109,
	VK_FORMAT_R64_UINT = 110,
	VK_FORMAT_R64_SINT = 111,
	VK_FORMAT_R64_SFLOAT = 112,
	VK_FORMAT_R64G64_UINT = 113,
	VK_FORMAT_R64G64_SINT = 114,
	VK_FORMAT_R64G64_SFLOAT = 115,
	VK_FORMAT_R64G64B64_UINT = 116,
	VK_FORMAT_R64G64B64_SINT = 117,
	VK_FORMAT_R64G64B64_SFLOAT = 118,
	VK_FORMAT_R64G64B64A64_UINT = 119,
	VK_FORMAT_R64G64B64A64_SINT = 120,
	VK_FORMAT_R64G64B64A64_SFLOAT = 121,
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
	VK_FORMAT_D16_UNORM = 124,
	VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
	VK_FORMAT_D32_SFLOAT = 126,
	VK_FORMAT_S8_UINT = 127,
	VK_FORMAT_D16_UNORM_S8_UINT = 128,
	VK_FORMAT_D24_UNORM_S8_UINT = 129,
	VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
	VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
	VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
	VK_FORMAT_BC2_UNORM_BLOCK = 135,
	VK_FORMAT_BC2_SRGB_BLOCK = 136,
	VK_FORMAT_BC3_UNORM_BLOCK = 137,
	VK_FORMAT_BC3_SRGB_BLOCK = 138,
	VK_FORMAT_BC4_UNORM_BLOCK = 139,
	VK_FORMAT_BC4_SNORM_BLOCK = 140,
	VK_FORMAT_BC5_UNORM_BLOCK = 141,
	VK_FORMAT_BC5_SNORM_BLOCK = 142,
	VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
	VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
	VK_FORMAT_BC7_UNORM_BLOCK = 145,
	VK_FORMAT_BC7_SRGB_BLOCK = 146,
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
	VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
	VK_FORMAT_BEGIN_RANGE = VK_FORMAT_UNDEFINED,
	VK_FORMAT_END_RANGE = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
	VK_FORMAT_RANGE_SIZE = (VK_FORMAT_ASTC_12x12_SRGB_BLOCK - VK_FORMAT_UNDEFINED + 1),
	VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
}

enum VkImageType {
	VK_IMAGE_TYPE_1D = 0,
	VK_IMAGE_TYPE_2D = 1,
	VK_IMAGE_TYPE_3D = 2,
	VK_IMAGE_TYPE_BEGIN_RANGE = VK_IMAGE_TYPE_1D,
	VK_IMAGE_TYPE_END_RANGE = VK_IMAGE_TYPE_3D,
	VK_IMAGE_TYPE_RANGE_SIZE = (VK_IMAGE_TYPE_3D - VK_IMAGE_TYPE_1D + 1),
	VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkImageTiling {
	VK_IMAGE_TILING_OPTIMAL = 0,
	VK_IMAGE_TILING_LINEAR = 1,
	VK_IMAGE_TILING_BEGIN_RANGE = VK_IMAGE_TILING_OPTIMAL,
	VK_IMAGE_TILING_END_RANGE = VK_IMAGE_TILING_LINEAR,
	VK_IMAGE_TILING_RANGE_SIZE = (VK_IMAGE_TILING_LINEAR - VK_IMAGE_TILING_OPTIMAL + 1),
	VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
}

enum VkPhysicalDeviceType {
	VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
	VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
	VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_OTHER,
	VK_PHYSICAL_DEVICE_TYPE_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_CPU,
	VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (VK_PHYSICAL_DEVICE_TYPE_CPU - VK_PHYSICAL_DEVICE_TYPE_OTHER + 1),
	VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkQueryType {
	VK_QUERY_TYPE_OCCLUSION = 0,
	VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
	VK_QUERY_TYPE_TIMESTAMP = 2,
	VK_QUERY_TYPE_BEGIN_RANGE = VK_QUERY_TYPE_OCCLUSION,
	VK_QUERY_TYPE_END_RANGE = VK_QUERY_TYPE_TIMESTAMP,
	VK_QUERY_TYPE_RANGE_SIZE = (VK_QUERY_TYPE_TIMESTAMP - VK_QUERY_TYPE_OCCLUSION + 1),
	VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkSharingMode {
	VK_SHARING_MODE_EXCLUSIVE = 0,
	VK_SHARING_MODE_CONCURRENT = 1,
	VK_SHARING_MODE_BEGIN_RANGE = VK_SHARING_MODE_EXCLUSIVE,
	VK_SHARING_MODE_END_RANGE = VK_SHARING_MODE_CONCURRENT,
	VK_SHARING_MODE_RANGE_SIZE = (VK_SHARING_MODE_CONCURRENT - VK_SHARING_MODE_EXCLUSIVE + 1),
	VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
}

enum VkImageLayout {
	VK_IMAGE_LAYOUT_UNDEFINED = 0,
	VK_IMAGE_LAYOUT_GENERAL = 1,
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
	VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
	VK_IMAGE_LAYOUT_BEGIN_RANGE = VK_IMAGE_LAYOUT_UNDEFINED,
	VK_IMAGE_LAYOUT_END_RANGE = VK_IMAGE_LAYOUT_PREINITIALIZED,
	VK_IMAGE_LAYOUT_RANGE_SIZE = (VK_IMAGE_LAYOUT_PREINITIALIZED - VK_IMAGE_LAYOUT_UNDEFINED + 1),
	VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
}

enum VkImageViewType {
	VK_IMAGE_VIEW_TYPE_1D = 0,
	VK_IMAGE_VIEW_TYPE_2D = 1,
	VK_IMAGE_VIEW_TYPE_3D = 2,
	VK_IMAGE_VIEW_TYPE_CUBE = 3,
	VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
	VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
	VK_IMAGE_VIEW_TYPE_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_1D,
	VK_IMAGE_VIEW_TYPE_END_RANGE = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
	VK_IMAGE_VIEW_TYPE_RANGE_SIZE = (VK_IMAGE_VIEW_TYPE_CUBE_ARRAY - VK_IMAGE_VIEW_TYPE_1D + 1),
	VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkComponentSwizzle {
	VK_COMPONENT_SWIZZLE_IDENTITY = 0,
	VK_COMPONENT_SWIZZLE_ZERO = 1,
	VK_COMPONENT_SWIZZLE_ONE = 2,
	VK_COMPONENT_SWIZZLE_R = 3,
	VK_COMPONENT_SWIZZLE_G = 4,
	VK_COMPONENT_SWIZZLE_B = 5,
	VK_COMPONENT_SWIZZLE_A = 6,
	VK_COMPONENT_SWIZZLE_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_IDENTITY,
	VK_COMPONENT_SWIZZLE_END_RANGE = VK_COMPONENT_SWIZZLE_A,
	VK_COMPONENT_SWIZZLE_RANGE_SIZE = (VK_COMPONENT_SWIZZLE_A - VK_COMPONENT_SWIZZLE_IDENTITY + 1),
	VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
}

enum VkVertexInputRate {
	VK_VERTEX_INPUT_RATE_VERTEX = 0,
	VK_VERTEX_INPUT_RATE_INSTANCE = 1,
	VK_VERTEX_INPUT_RATE_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_VERTEX,
	VK_VERTEX_INPUT_RATE_END_RANGE = VK_VERTEX_INPUT_RATE_INSTANCE,
	VK_VERTEX_INPUT_RATE_RANGE_SIZE = (VK_VERTEX_INPUT_RATE_INSTANCE - VK_VERTEX_INPUT_RATE_VERTEX + 1),
	VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
}

enum VkPrimitiveTopology {
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
	VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
	VK_PRIMITIVE_TOPOLOGY_END_RANGE = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
	VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = (VK_PRIMITIVE_TOPOLOGY_PATCH_LIST - VK_PRIMITIVE_TOPOLOGY_POINT_LIST + 1),
	VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
}

enum VkPolygonMode {
	VK_POLYGON_MODE_FILL = 0,
	VK_POLYGON_MODE_LINE = 1,
	VK_POLYGON_MODE_POINT = 2,
	VK_POLYGON_MODE_BEGIN_RANGE = VK_POLYGON_MODE_FILL,
	VK_POLYGON_MODE_END_RANGE = VK_POLYGON_MODE_POINT,
	VK_POLYGON_MODE_RANGE_SIZE = (VK_POLYGON_MODE_POINT - VK_POLYGON_MODE_FILL + 1),
	VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
}

enum VkFrontFace {
	VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
	VK_FRONT_FACE_CLOCKWISE = 1,
	VK_FRONT_FACE_BEGIN_RANGE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
	VK_FRONT_FACE_END_RANGE = VK_FRONT_FACE_CLOCKWISE,
	VK_FRONT_FACE_RANGE_SIZE = (VK_FRONT_FACE_CLOCKWISE - VK_FRONT_FACE_COUNTER_CLOCKWISE + 1),
	VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
}

enum VkCompareOp {
	VK_COMPARE_OP_NEVER = 0,
	VK_COMPARE_OP_LESS = 1,
	VK_COMPARE_OP_EQUAL = 2,
	VK_COMPARE_OP_LESS_OR_EQUAL = 3,
	VK_COMPARE_OP_GREATER = 4,
	VK_COMPARE_OP_NOT_EQUAL = 5,
	VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
	VK_COMPARE_OP_ALWAYS = 7,
	VK_COMPARE_OP_BEGIN_RANGE = VK_COMPARE_OP_NEVER,
	VK_COMPARE_OP_END_RANGE = VK_COMPARE_OP_ALWAYS,
	VK_COMPARE_OP_RANGE_SIZE = (VK_COMPARE_OP_ALWAYS - VK_COMPARE_OP_NEVER + 1),
	VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
}

enum VkStencilOp {
	VK_STENCIL_OP_KEEP = 0,
	VK_STENCIL_OP_ZERO = 1,
	VK_STENCIL_OP_REPLACE = 2,
	VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
	VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
	VK_STENCIL_OP_INVERT = 5,
	VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
	VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
	VK_STENCIL_OP_BEGIN_RANGE = VK_STENCIL_OP_KEEP,
	VK_STENCIL_OP_END_RANGE = VK_STENCIL_OP_DECREMENT_AND_WRAP,
	VK_STENCIL_OP_RANGE_SIZE = (VK_STENCIL_OP_DECREMENT_AND_WRAP - VK_STENCIL_OP_KEEP + 1),
	VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
}

enum VkLogicOp {
	VK_LOGIC_OP_CLEAR = 0,
	VK_LOGIC_OP_AND = 1,
	VK_LOGIC_OP_AND_REVERSE = 2,
	VK_LOGIC_OP_COPY = 3,
	VK_LOGIC_OP_AND_INVERTED = 4,
	VK_LOGIC_OP_NO_OP = 5,
	VK_LOGIC_OP_XOR = 6,
	VK_LOGIC_OP_OR = 7,
	VK_LOGIC_OP_NOR = 8,
	VK_LOGIC_OP_EQUIVALENT = 9,
	VK_LOGIC_OP_INVERT = 10,
	VK_LOGIC_OP_OR_REVERSE = 11,
	VK_LOGIC_OP_COPY_INVERTED = 12,
	VK_LOGIC_OP_OR_INVERTED = 13,
	VK_LOGIC_OP_NAND = 14,
	VK_LOGIC_OP_SET = 15,
	VK_LOGIC_OP_BEGIN_RANGE = VK_LOGIC_OP_CLEAR,
	VK_LOGIC_OP_END_RANGE = VK_LOGIC_OP_SET,
	VK_LOGIC_OP_RANGE_SIZE = (VK_LOGIC_OP_SET - VK_LOGIC_OP_CLEAR + 1),
	VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
}

enum VkBlendFactor {
	VK_BLEND_FACTOR_ZERO = 0,
	VK_BLEND_FACTOR_ONE = 1,
	VK_BLEND_FACTOR_SRC_COLOR = 2,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
	VK_BLEND_FACTOR_DST_COLOR = 4,
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
	VK_BLEND_FACTOR_SRC_ALPHA = 6,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
	VK_BLEND_FACTOR_DST_ALPHA = 8,
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
	VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
	VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
	VK_BLEND_FACTOR_SRC1_COLOR = 15,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
	VK_BLEND_FACTOR_SRC1_ALPHA = 17,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
	VK_BLEND_FACTOR_BEGIN_RANGE = VK_BLEND_FACTOR_ZERO,
	VK_BLEND_FACTOR_END_RANGE = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
	VK_BLEND_FACTOR_RANGE_SIZE = (VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - VK_BLEND_FACTOR_ZERO + 1),
	VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
}

enum VkBlendOp {
	VK_BLEND_OP_ADD = 0,
	VK_BLEND_OP_SUBTRACT = 1,
	VK_BLEND_OP_REVERSE_SUBTRACT = 2,
	VK_BLEND_OP_MIN = 3,
	VK_BLEND_OP_MAX = 4,
	VK_BLEND_OP_BEGIN_RANGE = VK_BLEND_OP_ADD,
	VK_BLEND_OP_END_RANGE = VK_BLEND_OP_MAX,
	VK_BLEND_OP_RANGE_SIZE = (VK_BLEND_OP_MAX - VK_BLEND_OP_ADD + 1),
	VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
}

enum VkDynamicState {
	VK_DYNAMIC_STATE_VIEWPORT = 0,
	VK_DYNAMIC_STATE_SCISSOR = 1,
	VK_DYNAMIC_STATE_LINE_WIDTH = 2,
	VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
	VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
	VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
	VK_DYNAMIC_STATE_BEGIN_RANGE = VK_DYNAMIC_STATE_VIEWPORT,
	VK_DYNAMIC_STATE_END_RANGE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
	VK_DYNAMIC_STATE_RANGE_SIZE = (VK_DYNAMIC_STATE_STENCIL_REFERENCE - VK_DYNAMIC_STATE_VIEWPORT + 1),
	VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
}

enum VkFilter {
	VK_FILTER_NEAREST = 0,
	VK_FILTER_LINEAR = 1,
	VK_FILTER_BEGIN_RANGE = VK_FILTER_NEAREST,
	VK_FILTER_END_RANGE = VK_FILTER_LINEAR,
	VK_FILTER_RANGE_SIZE = (VK_FILTER_LINEAR - VK_FILTER_NEAREST + 1),
	VK_FILTER_MAX_ENUM = 0x7FFFFFFF
}

enum VkSamplerMipmapMode {
	VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
	VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
	VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_NEAREST,
	VK_SAMPLER_MIPMAP_MODE_END_RANGE = VK_SAMPLER_MIPMAP_MODE_LINEAR,
	VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = (VK_SAMPLER_MIPMAP_MODE_LINEAR - VK_SAMPLER_MIPMAP_MODE_NEAREST + 1),
	VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
}

enum VkSamplerAddressMode {
	VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
	VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_REPEAT,
	VK_SAMPLER_ADDRESS_MODE_END_RANGE = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
	VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = (VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE - VK_SAMPLER_ADDRESS_MODE_REPEAT + 1),
	VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
}

enum VkBorderColor {
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
	VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
	VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
	VK_BORDER_COLOR_BEGIN_RANGE = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
	VK_BORDER_COLOR_END_RANGE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
	VK_BORDER_COLOR_RANGE_SIZE = (VK_BORDER_COLOR_INT_OPAQUE_WHITE - VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1),
	VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
}

enum VkDescriptorType {
	VK_DESCRIPTOR_TYPE_SAMPLER = 0,
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
	VK_DESCRIPTOR_TYPE_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_SAMPLER,
	VK_DESCRIPTOR_TYPE_END_RANGE = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
	VK_DESCRIPTOR_TYPE_RANGE_SIZE = (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT - VK_DESCRIPTOR_TYPE_SAMPLER + 1),
	VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkAttachmentLoadOp {
	VK_ATTACHMENT_LOAD_OP_LOAD = 0,
	VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
	VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
	VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_LOAD,
	VK_ATTACHMENT_LOAD_OP_END_RANGE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
	VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = (VK_ATTACHMENT_LOAD_OP_DONT_CARE - VK_ATTACHMENT_LOAD_OP_LOAD + 1),
	VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
}

enum VkAttachmentStoreOp {
	VK_ATTACHMENT_STORE_OP_STORE = 0,
	VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
	VK_ATTACHMENT_STORE_OP_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_STORE,
	VK_ATTACHMENT_STORE_OP_END_RANGE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
	VK_ATTACHMENT_STORE_OP_RANGE_SIZE = (VK_ATTACHMENT_STORE_OP_DONT_CARE - VK_ATTACHMENT_STORE_OP_STORE + 1),
	VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
}

enum VkPipelineBindPoint {
	VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
	VK_PIPELINE_BIND_POINT_COMPUTE = 1,
	VK_PIPELINE_BIND_POINT_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_GRAPHICS,
	VK_PIPELINE_BIND_POINT_END_RANGE = VK_PIPELINE_BIND_POINT_COMPUTE,
	VK_PIPELINE_BIND_POINT_RANGE_SIZE = (VK_PIPELINE_BIND_POINT_COMPUTE - VK_PIPELINE_BIND_POINT_GRAPHICS + 1),
	VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
}

enum VkCommandBufferLevel {
	VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
	VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
	VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
	VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
	VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + 1),
	VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
}

enum VkIndexType {
	VK_INDEX_TYPE_UINT16 = 0,
	VK_INDEX_TYPE_UINT32 = 1,
	VK_INDEX_TYPE_BEGIN_RANGE = VK_INDEX_TYPE_UINT16,
	VK_INDEX_TYPE_END_RANGE = VK_INDEX_TYPE_UINT32,
	VK_INDEX_TYPE_RANGE_SIZE = (VK_INDEX_TYPE_UINT32 - VK_INDEX_TYPE_UINT16 + 1),
	VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
}

enum VkSubpassContents {
	VK_SUBPASS_CONTENTS_INLINE = 0,
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
	VK_SUBPASS_CONTENTS_BEGIN_RANGE = VK_SUBPASS_CONTENTS_INLINE,
	VK_SUBPASS_CONTENTS_END_RANGE = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
	VK_SUBPASS_CONTENTS_RANGE_SIZE = (VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - VK_SUBPASS_CONTENTS_INLINE + 1),
	VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
}

alias VkInstanceCreateFlags = VkFlags;

enum VkFormatFeatureFlagBits {
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
	VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
	VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
}

alias VkFormatFeatureFlags = VkFlags;

enum VkImageUsageFlagBits {
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
	VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
}

alias VkImageUsageFlags = VkFlags;

enum VkImageCreateFlagBits {
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
}

alias VkImageCreateFlags = VkFlags;

enum VkSampleCountFlagBits {
	VK_SAMPLE_COUNT_1_BIT = 0x00000001,
	VK_SAMPLE_COUNT_2_BIT = 0x00000002,
	VK_SAMPLE_COUNT_4_BIT = 0x00000004,
	VK_SAMPLE_COUNT_8_BIT = 0x00000008,
	VK_SAMPLE_COUNT_16_BIT = 0x00000010,
	VK_SAMPLE_COUNT_32_BIT = 0x00000020,
	VK_SAMPLE_COUNT_64_BIT = 0x00000040,
}

alias VkSampleCountFlags = VkFlags;

enum VkQueueFlagBits {
	VK_QUEUE_GRAPHICS_BIT = 0x00000001,
	VK_QUEUE_COMPUTE_BIT = 0x00000002,
	VK_QUEUE_TRANSFER_BIT = 0x00000004,
	VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
}

alias VkQueueFlags = VkFlags;

enum VkMemoryPropertyFlagBits {
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
}

alias VkMemoryPropertyFlags = VkFlags;

enum VkMemoryHeapFlagBits {
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
}

alias VkMemoryHeapFlags = VkFlags;

alias VkDeviceCreateFlags = VkFlags;

alias VkDeviceQueueCreateFlags = VkFlags;

enum VkPipelineStageFlagBits {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
}

alias VkPipelineStageFlags = VkFlags;

alias VkMemoryMapFlags = VkFlags;

enum VkImageAspectFlagBits {
	VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
	VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
	VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
	VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
}

alias VkImageAspectFlags = VkFlags;

enum VkSparseImageFormatFlagBits {
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
}

alias VkSparseImageFormatFlags = VkFlags;

enum VkSparseMemoryBindFlagBits {
	VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
}

alias VkSparseMemoryBindFlags = VkFlags;

enum VkFenceCreateFlagBits {
	VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
}

alias VkFenceCreateFlags = VkFlags;

alias VkSemaphoreCreateFlags = VkFlags;

alias VkEventCreateFlags = VkFlags;

alias VkQueryPoolCreateFlags = VkFlags;

enum VkQueryPipelineStatisticFlagBits {
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
}

alias VkQueryPipelineStatisticFlags = VkFlags;

enum VkQueryResultFlagBits {
	VK_QUERY_RESULT_64_BIT = 0x00000001,
	VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
	VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
}

alias VkQueryResultFlags = VkFlags;

enum VkBufferCreateFlagBits {
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
}

alias VkBufferCreateFlags = VkFlags;

enum VkBufferUsageFlagBits {
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
}

alias VkBufferUsageFlags = VkFlags;

alias VkBufferViewCreateFlags = VkFlags;

alias VkImageViewCreateFlags = VkFlags;

alias VkShaderModuleCreateFlags = VkFlags;

alias VkPipelineCacheCreateFlags = VkFlags;

enum VkPipelineCreateFlagBits {
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
	VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
}

alias VkPipelineCreateFlags = VkFlags;

alias VkPipelineShaderStageCreateFlags = VkFlags;

enum VkShaderStageFlagBits {
	VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
	VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
	VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
	VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
	VK_SHADER_STAGE_ALL_GRAPHICS = 0x1F,
	VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
}

alias VkPipelineVertexInputStateCreateFlags = VkFlags;

alias VkPipelineInputAssemblyStateCreateFlags = VkFlags;

alias VkPipelineTessellationStateCreateFlags = VkFlags;

alias VkPipelineViewportStateCreateFlags = VkFlags;

alias VkPipelineRasterizationStateCreateFlags = VkFlags;

enum VkCullModeFlagBits {
	VK_CULL_MODE_NONE = 0,
	VK_CULL_MODE_FRONT_BIT = 0x00000001,
	VK_CULL_MODE_BACK_BIT = 0x00000002,
	VK_CULL_MODE_FRONT_AND_BACK = 0x3,
}

alias VkCullModeFlags = VkFlags;

alias VkPipelineMultisampleStateCreateFlags = VkFlags;

alias VkPipelineDepthStencilStateCreateFlags = VkFlags;

alias VkPipelineColorBlendStateCreateFlags = VkFlags;

enum VkColorComponentFlagBits {
	VK_COLOR_COMPONENT_R_BIT = 0x00000001,
	VK_COLOR_COMPONENT_G_BIT = 0x00000002,
	VK_COLOR_COMPONENT_B_BIT = 0x00000004,
	VK_COLOR_COMPONENT_A_BIT = 0x00000008,
}

alias VkColorComponentFlags = VkFlags;

alias VkPipelineDynamicStateCreateFlags = VkFlags;

alias VkPipelineLayoutCreateFlags = VkFlags;

alias VkShaderStageFlags = VkFlags;

alias VkSamplerCreateFlags = VkFlags;

alias VkDescriptorSetLayoutCreateFlags = VkFlags;

enum VkDescriptorPoolCreateFlagBits {
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
}

alias VkDescriptorPoolCreateFlags = VkFlags;

alias VkDescriptorPoolResetFlags = VkFlags;

alias VkFramebufferCreateFlags = VkFlags;

alias VkRenderPassCreateFlags = VkFlags;

enum VkAttachmentDescriptionFlagBits {
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
}

alias VkAttachmentDescriptionFlags = VkFlags;

alias VkSubpassDescriptionFlags = VkFlags;

enum VkAccessFlagBits {
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
	VK_ACCESS_INDEX_READ_BIT = 0x00000002,
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
	VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
	VK_ACCESS_SHADER_READ_BIT = 0x00000020,
	VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
	VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
	VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
	VK_ACCESS_HOST_READ_BIT = 0x00002000,
	VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
	VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
	VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
}

alias VkAccessFlags = VkFlags;

enum VkDependencyFlagBits {
	VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
}

alias VkDependencyFlags = VkFlags;

enum VkCommandPoolCreateFlagBits {
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
}

alias VkCommandPoolCreateFlags = VkFlags;

enum VkCommandPoolResetFlagBits {
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
}

alias VkCommandPoolResetFlags = VkFlags;

enum VkCommandBufferUsageFlagBits {
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
}

alias VkCommandBufferUsageFlags = VkFlags;

enum VkQueryControlFlagBits {
	VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
}

alias VkQueryControlFlags = VkFlags;

enum VkCommandBufferResetFlagBits {
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
}

alias VkCommandBufferResetFlags = VkFlags;

enum VkStencilFaceFlagBits {
	VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
	VK_STENCIL_FACE_BACK_BIT = 0x00000002,
	VK_STENCIL_FRONT_AND_BACK = 0x3,
}

alias VkStencilFaceFlags = VkFlags;

alias PFN_vkAllocationFunction = nothrow void* function(void* pUserData, size_t size, size_t alignment, VkSystemAllocationScope allocationScope);

alias PFN_vkReallocationFunction = nothrow void* function(void* pUserData, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocationScope);

alias PFN_vkFreeFunction = nothrow void function(void* pUserData, void* pMemory);

alias PFN_vkInternalAllocationNotification = nothrow void function(void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope);

alias PFN_vkInternalFreeNotification = nothrow void function(void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope);

alias PFN_vkVoidFunction = nothrow void function();

struct VkApplicationInfo {
	VkStructureType sType;
	const(void)* pNext;
	const(char)* pApplicationName;
	uint applicationVersion;
	const(char)* pEngineName;
	uint engineVersion;
	uint apiVersion;
}

struct VkInstanceCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkInstanceCreateFlags flags;
	const(VkApplicationInfo)* pApplicationInfo;
	uint enabledLayerCount;
	const(char*)* ppEnabledLayerNames;
	uint enabledExtensionCount;
	const(char*)* ppEnabledExtensionNames;
}

struct VkAllocationCallbacks {
	void* pUserData;
	PFN_vkAllocationFunction pfnAllocation;
	PFN_vkReallocationFunction pfnReallocation;
	PFN_vkFreeFunction pfnFree;
	PFN_vkInternalAllocationNotification pfnInternalAllocation;
	PFN_vkInternalFreeNotification pfnInternalFree;
}

struct VkPhysicalDeviceFeatures {
	VkBool32 robustBufferAccess;
	VkBool32 fullDrawIndexUint32;
	VkBool32 imageCubeArray;
	VkBool32 independentBlend;
	VkBool32 geometryShader;
	VkBool32 tessellationShader;
	VkBool32 sampleRateShading;
	VkBool32 dualSrcBlend;
	VkBool32 logicOp;
	VkBool32 multiDrawIndirect;
	VkBool32 drawIndirectFirstInstance;
	VkBool32 depthClamp;
	VkBool32 depthBiasClamp;
	VkBool32 fillModeNonSolid;
	VkBool32 depthBounds;
	VkBool32 wideLines;
	VkBool32 largePoints;
	VkBool32 alphaToOne;
	VkBool32 multiViewport;
	VkBool32 samplerAnisotropy;
	VkBool32 textureCompressionETC2;
	VkBool32 textureCompressionASTC_LDR;
	VkBool32 textureCompressionBC;
	VkBool32 occlusionQueryPrecise;
	VkBool32 pipelineStatisticsQuery;
	VkBool32 vertexPipelineStoresAndAtomics;
	VkBool32 fragmentStoresAndAtomics;
	VkBool32 shaderTessellationAndGeometryPointSize;
	VkBool32 shaderImageGatherExtended;
	VkBool32 shaderStorageImageExtendedFormats;
	VkBool32 shaderStorageImageMultisample;
	VkBool32 shaderStorageImageReadWithoutFormat;
	VkBool32 shaderStorageImageWriteWithoutFormat;
	VkBool32 shaderUniformBufferArrayDynamicIndexing;
	VkBool32 shaderSampledImageArrayDynamicIndexing;
	VkBool32 shaderStorageBufferArrayDynamicIndexing;
	VkBool32 shaderStorageImageArrayDynamicIndexing;
	VkBool32 shaderClipDistance;
	VkBool32 shaderCullDistance;
	VkBool32 shaderFloat64;
	VkBool32 shaderInt64;
	VkBool32 shaderInt16;
	VkBool32 shaderResourceResidency;
	VkBool32 shaderResourceMinLod;
	VkBool32 sparseBinding;
	VkBool32 sparseResidencyBuffer;
	VkBool32 sparseResidencyImage2D;
	VkBool32 sparseResidencyImage3D;
	VkBool32 sparseResidency2Samples;
	VkBool32 sparseResidency4Samples;
	VkBool32 sparseResidency8Samples;
	VkBool32 sparseResidency16Samples;
	VkBool32 sparseResidencyAliased;
	VkBool32 variableMultisampleRate;
	VkBool32 inheritedQueries;
}

struct VkFormatProperties {
	VkFormatFeatureFlags linearTilingFeatures;
	VkFormatFeatureFlags optimalTilingFeatures;
	VkFormatFeatureFlags bufferFeatures;
}

struct VkExtent3D {
	uint width;
	uint height;
	uint depth;
}

struct VkImageFormatProperties {
	VkExtent3D maxExtent;
	uint maxMipLevels;
	uint maxArrayLayers;
	VkSampleCountFlags sampleCounts;
	VkDeviceSize maxResourceSize;
}

struct VkPhysicalDeviceLimits {
	uint maxImageDimension1D;
	uint maxImageDimension2D;
	uint maxImageDimension3D;
	uint maxImageDimensionCube;
	uint maxImageArrayLayers;
	uint maxTexelBufferElements;
	uint maxUniformBufferRange;
	uint maxStorageBufferRange;
	uint maxPushConstantsSize;
	uint maxMemoryAllocationCount;
	uint maxSamplerAllocationCount;
	VkDeviceSize bufferImageGranularity;
	VkDeviceSize sparseAddressSpaceSize;
	uint maxBoundDescriptorSets;
	uint maxPerStageDescriptorSamplers;
	uint maxPerStageDescriptorUniformBuffers;
	uint maxPerStageDescriptorStorageBuffers;
	uint maxPerStageDescriptorSampledImages;
	uint maxPerStageDescriptorStorageImages;
	uint maxPerStageDescriptorInputAttachments;
	uint maxPerStageResources;
	uint maxDescriptorSetSamplers;
	uint maxDescriptorSetUniformBuffers;
	uint maxDescriptorSetUniformBuffersDynamic;
	uint maxDescriptorSetStorageBuffers;
	uint maxDescriptorSetStorageBuffersDynamic;
	uint maxDescriptorSetSampledImages;
	uint maxDescriptorSetStorageImages;
	uint maxDescriptorSetInputAttachments;
	uint maxVertexInputAttributes;
	uint maxVertexInputBindings;
	uint maxVertexInputAttributeOffset;
	uint maxVertexInputBindingStride;
	uint maxVertexOutputComponents;
	uint maxTessellationGenerationLevel;
	uint maxTessellationPatchSize;
	uint maxTessellationControlPerVertexInputComponents;
	uint maxTessellationControlPerVertexOutputComponents;
	uint maxTessellationControlPerPatchOutputComponents;
	uint maxTessellationControlTotalOutputComponents;
	uint maxTessellationEvaluationInputComponents;
	uint maxTessellationEvaluationOutputComponents;
	uint maxGeometryShaderInvocations;
	uint maxGeometryInputComponents;
	uint maxGeometryOutputComponents;
	uint maxGeometryOutputVertices;
	uint maxGeometryTotalOutputComponents;
	uint maxFragmentInputComponents;
	uint maxFragmentOutputAttachments;
	uint maxFragmentDualSrcAttachments;
	uint maxFragmentCombinedOutputResources;
	uint maxComputeSharedMemorySize;
	uint[3] maxComputeWorkGroupCount;
	uint maxComputeWorkGroupInvocations;
	uint[3] maxComputeWorkGroupSize;
	uint subPixelPrecisionBits;
	uint subTexelPrecisionBits;
	uint mipmapPrecisionBits;
	uint maxDrawIndexedIndexValue;
	uint maxDrawIndirectCount;
	float maxSamplerLodBias;
	float maxSamplerAnisotropy;
	uint maxViewports;
	uint[2] maxViewportDimensions;
	float[2] viewportBoundsRange;
	uint viewportSubPixelBits;
	size_t minMemoryMapAlignment;
	VkDeviceSize minTexelBufferOffsetAlignment;
	VkDeviceSize minUniformBufferOffsetAlignment;
	VkDeviceSize minStorageBufferOffsetAlignment;
	int minTexelOffset;
	uint maxTexelOffset;
	int minTexelGatherOffset;
	uint maxTexelGatherOffset;
	float minInterpolationOffset;
	float maxInterpolationOffset;
	uint subPixelInterpolationOffsetBits;
	uint maxFramebufferWidth;
	uint maxFramebufferHeight;
	uint maxFramebufferLayers;
	VkSampleCountFlags framebufferColorSampleCounts;
	VkSampleCountFlags framebufferDepthSampleCounts;
	VkSampleCountFlags framebufferStencilSampleCounts;
	VkSampleCountFlags framebufferNoAttachmentsSampleCounts;
	uint maxColorAttachments;
	VkSampleCountFlags sampledImageColorSampleCounts;
	VkSampleCountFlags sampledImageIntegerSampleCounts;
	VkSampleCountFlags sampledImageDepthSampleCounts;
	VkSampleCountFlags sampledImageStencilSampleCounts;
	VkSampleCountFlags storageImageSampleCounts;
	uint maxSampleMaskWords;
	VkBool32 timestampComputeAndGraphics;
	float timestampPeriod;
	uint maxClipDistances;
	uint maxCullDistances;
	uint maxCombinedClipAndCullDistances;
	uint discreteQueuePriorities;
	float[2] pointSizeRange;
	float[2] lineWidthRange;
	float pointSizeGranularity;
	float lineWidthGranularity;
	VkBool32 strictLines;
	VkBool32 standardSampleLocations;
	VkDeviceSize optimalBufferCopyOffsetAlignment;
	VkDeviceSize optimalBufferCopyRowPitchAlignment;
	VkDeviceSize nonCoherentAtomSize;
}

struct VkPhysicalDeviceSparseProperties {
	VkBool32 residencyStandard2DBlockShape;
	VkBool32 residencyStandard2DMultisampleBlockShape;
	VkBool32 residencyStandard3DBlockShape;
	VkBool32 residencyAlignedMipSize;
	VkBool32 residencyNonResidentStrict;
}

struct VkPhysicalDeviceProperties {
	uint apiVersion;
	uint driverVersion;
	uint vendorID;
	uint deviceID;
	VkPhysicalDeviceType deviceType;
	char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] deviceName;
	ubyte[VK_UUID_SIZE] pipelineCacheUUID;
	VkPhysicalDeviceLimits limits;
	VkPhysicalDeviceSparseProperties sparseProperties;
}

struct VkQueueFamilyProperties {
	VkQueueFlags queueFlags;
	uint queueCount;
	uint timestampValidBits;
	VkExtent3D minImageTransferGranularity;
}

struct VkMemoryType {
	VkMemoryPropertyFlags propertyFlags;
	uint heapIndex;
}

struct VkMemoryHeap {
	VkDeviceSize size;
	VkMemoryHeapFlags flags;
}

struct VkPhysicalDeviceMemoryProperties {
	uint memoryTypeCount;
	VkMemoryType[VK_MAX_MEMORY_TYPES] memoryTypes;
	uint memoryHeapCount;
	VkMemoryHeap[VK_MAX_MEMORY_HEAPS] memoryHeaps;
}

struct VkDeviceQueueCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkDeviceQueueCreateFlags flags;
	uint queueFamilyIndex;
	uint queueCount;
	const(float)* pQueuePriorities;
}

struct VkDeviceCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkDeviceCreateFlags flags;
	uint queueCreateInfoCount;
	const(VkDeviceQueueCreateInfo)* pQueueCreateInfos;
	uint enabledLayerCount;
	const(char*)* ppEnabledLayerNames;
	uint enabledExtensionCount;
	const(char*)* ppEnabledExtensionNames;
	const(VkPhysicalDeviceFeatures)* pEnabledFeatures;
}

struct VkExtensionProperties {
	char[VK_MAX_EXTENSION_NAME_SIZE] extensionName;
	uint specVersion;
}

struct VkLayerProperties {
	char[VK_MAX_EXTENSION_NAME_SIZE] layerName;
	uint specVersion;
	uint implementationVersion;
	char[VK_MAX_DESCRIPTION_SIZE] description;
}

struct VkSubmitInfo {
	VkStructureType sType;
	const(void)* pNext;
	uint waitSemaphoreCount;
	const(VkSemaphore)* pWaitSemaphores;
	const(VkPipelineStageFlags)* pWaitDstStageMask;
	uint commandBufferCount;
	const(VkCommandBuffer)* pCommandBuffers;
	uint signalSemaphoreCount;
	const(VkSemaphore)* pSignalSemaphores;
}

struct VkMemoryAllocateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkDeviceSize allocationSize;
	uint memoryTypeIndex;
}

struct VkMappedMemoryRange {
	VkStructureType sType;
	const(void)* pNext;
	VkDeviceMemory memory;
	VkDeviceSize offset;
	VkDeviceSize size;
}

struct VkMemoryRequirements {
	VkDeviceSize size;
	VkDeviceSize alignment;
	uint memoryTypeBits;
}

struct VkSparseImageFormatProperties {
	VkImageAspectFlags aspectMask;
	VkExtent3D imageGranularity;
	VkSparseImageFormatFlags flags;
}

struct VkSparseImageMemoryRequirements {
	VkSparseImageFormatProperties formatProperties;
	uint imageMipTailFirstLod;
	VkDeviceSize imageMipTailSize;
	VkDeviceSize imageMipTailOffset;
	VkDeviceSize imageMipTailStride;
}

struct VkSparseMemoryBind {
	VkDeviceSize resourceOffset;
	VkDeviceSize size;
	VkDeviceMemory memory;
	VkDeviceSize memoryOffset;
	VkSparseMemoryBindFlags flags;
}

struct VkSparseBufferMemoryBindInfo {
	VkBuffer buffer;
	uint bindCount;
	const(VkSparseMemoryBind)* pBinds;
}

struct VkSparseImageOpaqueMemoryBindInfo {
	VkImage image;
	uint bindCount;
	const(VkSparseMemoryBind)* pBinds;
}

struct VkImageSubresource {
	VkImageAspectFlags aspectMask;
	uint mipLevel;
	uint arrayLayer;
}

struct VkOffset3D {
	int x;
	int y;
	int z;
}

struct VkSparseImageMemoryBind {
	VkImageSubresource subresource;
	VkOffset3D offset;
	VkExtent3D extent;
	VkDeviceMemory memory;
	VkDeviceSize memoryOffset;
	VkSparseMemoryBindFlags flags;
}

struct VkSparseImageMemoryBindInfo {
	VkImage image;
	uint bindCount;
	const(VkSparseImageMemoryBind)* pBinds;
}

struct VkBindSparseInfo {
	VkStructureType sType;
	const(void)* pNext;
	uint waitSemaphoreCount;
	const(VkSemaphore)* pWaitSemaphores;
	uint bufferBindCount;
	const(VkSparseBufferMemoryBindInfo)* pBufferBinds;
	uint imageOpaqueBindCount;
	const(VkSparseImageOpaqueMemoryBindInfo)* pImageOpaqueBinds;
	uint imageBindCount;
	const(VkSparseImageMemoryBindInfo)* pImageBinds;
	uint signalSemaphoreCount;
	const(VkSemaphore)* pSignalSemaphores;
}

struct VkFenceCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkFenceCreateFlags flags;
}

struct VkSemaphoreCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkSemaphoreCreateFlags flags;
}

struct VkEventCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkEventCreateFlags flags;
}

struct VkQueryPoolCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkQueryPoolCreateFlags flags;
	VkQueryType queryType;
	uint queryCount;
	VkQueryPipelineStatisticFlags pipelineStatistics;
}

struct VkBufferCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkBufferCreateFlags flags;
	VkDeviceSize size;
	VkBufferUsageFlags usage;
	VkSharingMode sharingMode;
	uint queueFamilyIndexCount;
	const(uint)* pQueueFamilyIndices;
}

struct VkBufferViewCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkBufferViewCreateFlags flags;
	VkBuffer buffer;
	VkFormat format;
	VkDeviceSize offset;
	VkDeviceSize range;
}

struct VkImageCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkImageCreateFlags flags;
	VkImageType imageType;
	VkFormat format;
	VkExtent3D extent;
	uint mipLevels;
	uint arrayLayers;
	VkSampleCountFlagBits samples;
	VkImageTiling tiling;
	VkImageUsageFlags usage;
	VkSharingMode sharingMode;
	uint queueFamilyIndexCount;
	const(uint)* pQueueFamilyIndices;
	VkImageLayout initialLayout;
}

struct VkSubresourceLayout {
	VkDeviceSize offset;
	VkDeviceSize size;
	VkDeviceSize rowPitch;
	VkDeviceSize arrayPitch;
	VkDeviceSize depthPitch;
}

struct VkComponentMapping {
	VkComponentSwizzle r;
	VkComponentSwizzle g;
	VkComponentSwizzle b;
	VkComponentSwizzle a;
}

struct VkImageSubresourceRange {
	VkImageAspectFlags aspectMask;
	uint baseMipLevel;
	uint levelCount;
	uint baseArrayLayer;
	uint layerCount;
}

struct VkImageViewCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkImageViewCreateFlags flags;
	VkImage image;
	VkImageViewType viewType;
	VkFormat format;
	VkComponentMapping components;
	VkImageSubresourceRange subresourceRange;
}

struct VkShaderModuleCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkShaderModuleCreateFlags flags;
	size_t codeSize;
	const(uint)* pCode;
}

struct VkPipelineCacheCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineCacheCreateFlags flags;
	size_t initialDataSize;
	const(void)* pInitialData;
}

struct VkSpecializationMapEntry {
	uint constantID;
	uint offset;
	size_t size;
}

struct VkSpecializationInfo {
	uint mapEntryCount;
	const(VkSpecializationMapEntry)* pMapEntries;
	size_t dataSize;
	const(void)* pData;
}

struct VkPipelineShaderStageCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineShaderStageCreateFlags flags;
	VkShaderStageFlagBits stage;
	VkShaderModule module_;
	const(char)* pName;
	const(VkSpecializationInfo)* pSpecializationInfo;
}

struct VkVertexInputBindingDescription {
	uint binding;
	uint stride;
	VkVertexInputRate inputRate;
}

struct VkVertexInputAttributeDescription {
	uint location;
	uint binding;
	VkFormat format;
	uint offset;
}

struct VkPipelineVertexInputStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineVertexInputStateCreateFlags flags;
	uint vertexBindingDescriptionCount;
	const(VkVertexInputBindingDescription)* pVertexBindingDescriptions;
	uint vertexAttributeDescriptionCount;
	const(VkVertexInputAttributeDescription)* pVertexAttributeDescriptions;
}

struct VkPipelineInputAssemblyStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineInputAssemblyStateCreateFlags flags;
	VkPrimitiveTopology topology;
	VkBool32 primitiveRestartEnable;
}

struct VkPipelineTessellationStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineTessellationStateCreateFlags flags;
	uint patchControlPoints;
}

struct VkViewport {
	float x;
	float y;
	float width;
	float height;
	float minDepth;
	float maxDepth;
}

struct VkOffset2D {
	int x;
	int y;
}

struct VkExtent2D {
	uint width;
	uint height;
}

struct VkRect2D {
	VkOffset2D offset;
	VkExtent2D extent;
}

struct VkPipelineViewportStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineViewportStateCreateFlags flags;
	uint viewportCount;
	const(VkViewport)* pViewports;
	uint scissorCount;
	const(VkRect2D)* pScissors;
}

struct VkPipelineRasterizationStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineRasterizationStateCreateFlags flags;
	VkBool32 depthClampEnable;
	VkBool32 rasterizerDiscardEnable;
	VkPolygonMode polygonMode;
	VkCullModeFlags cullMode;
	VkFrontFace frontFace;
	VkBool32 depthBiasEnable;
	float depthBiasConstantFactor;
	float depthBiasClamp;
	float depthBiasSlopeFactor;
	float lineWidth;
}

struct VkPipelineMultisampleStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineMultisampleStateCreateFlags flags;
	VkSampleCountFlagBits rasterizationSamples;
	VkBool32 sampleShadingEnable;
	float minSampleShading;
	const(VkSampleMask)* pSampleMask;
	VkBool32 alphaToCoverageEnable;
	VkBool32 alphaToOneEnable;
}

struct VkStencilOpState {
	VkStencilOp failOp;
	VkStencilOp passOp;
	VkStencilOp depthFailOp;
	VkCompareOp compareOp;
	uint compareMask;
	uint writeMask;
	uint reference;
}

struct VkPipelineDepthStencilStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineDepthStencilStateCreateFlags flags;
	VkBool32 depthTestEnable;
	VkBool32 depthWriteEnable;
	VkCompareOp depthCompareOp;
	VkBool32 depthBoundsTestEnable;
	VkBool32 stencilTestEnable;
	VkStencilOpState front;
	VkStencilOpState back;
	float minDepthBounds;
	float maxDepthBounds;
}

struct VkPipelineColorBlendAttachmentState {
	VkBool32 blendEnable;
	VkBlendFactor srcColorBlendFactor;
	VkBlendFactor dstColorBlendFactor;
	VkBlendOp colorBlendOp;
	VkBlendFactor srcAlphaBlendFactor;
	VkBlendFactor dstAlphaBlendFactor;
	VkBlendOp alphaBlendOp;
	VkColorComponentFlags colorWriteMask;
}

struct VkPipelineColorBlendStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineColorBlendStateCreateFlags flags;
	VkBool32 logicOpEnable;
	VkLogicOp logicOp;
	uint attachmentCount;
	const(VkPipelineColorBlendAttachmentState)* pAttachments;
	float[4] blendConstants;
}

struct VkPipelineDynamicStateCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineDynamicStateCreateFlags flags;
	uint dynamicStateCount;
	const(VkDynamicState)* pDynamicStates;
}

struct VkGraphicsPipelineCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineCreateFlags flags;
	uint stageCount;
	const(VkPipelineShaderStageCreateInfo)* pStages;
	const(VkPipelineVertexInputStateCreateInfo)* pVertexInputState;
	const(VkPipelineInputAssemblyStateCreateInfo)* pInputAssemblyState;
	const(VkPipelineTessellationStateCreateInfo)* pTessellationState;
	const(VkPipelineViewportStateCreateInfo)* pViewportState;
	const(VkPipelineRasterizationStateCreateInfo)* pRasterizationState;
	const(VkPipelineMultisampleStateCreateInfo)* pMultisampleState;
	const(VkPipelineDepthStencilStateCreateInfo)* pDepthStencilState;
	const(VkPipelineColorBlendStateCreateInfo)* pColorBlendState;
	const(VkPipelineDynamicStateCreateInfo)* pDynamicState;
	VkPipelineLayout layout;
	VkRenderPass renderPass;
	uint subpass;
	VkPipeline basePipelineHandle;
	int basePipelineIndex;
}

struct VkComputePipelineCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineCreateFlags flags;
	VkPipelineShaderStageCreateInfo stage;
	VkPipelineLayout layout;
	VkPipeline basePipelineHandle;
	int basePipelineIndex;
}

struct VkPushConstantRange {
	VkShaderStageFlags stageFlags;
	uint offset;
	uint size;
}

struct VkPipelineLayoutCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkPipelineLayoutCreateFlags flags;
	uint setLayoutCount;
	const(VkDescriptorSetLayout)* pSetLayouts;
	uint pushConstantRangeCount;
	const(VkPushConstantRange)* pPushConstantRanges;
}

struct VkSamplerCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkSamplerCreateFlags flags;
	VkFilter magFilter;
	VkFilter minFilter;
	VkSamplerMipmapMode mipmapMode;
	VkSamplerAddressMode addressModeU;
	VkSamplerAddressMode addressModeV;
	VkSamplerAddressMode addressModeW;
	float mipLodBias;
	VkBool32 anisotropyEnable;
	float maxAnisotropy;
	VkBool32 compareEnable;
	VkCompareOp compareOp;
	float minLod;
	float maxLod;
	VkBorderColor borderColor;
	VkBool32 unnormalizedCoordinates;
}

struct VkDescriptorSetLayoutBinding {
	uint binding;
	VkDescriptorType descriptorType;
	uint descriptorCount;
	VkShaderStageFlags stageFlags;
	const(VkSampler)* pImmutableSamplers;
}

struct VkDescriptorSetLayoutCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkDescriptorSetLayoutCreateFlags flags;
	uint bindingCount;
	const(VkDescriptorSetLayoutBinding)* pBindings;
}

struct VkDescriptorPoolSize {
	VkDescriptorType type;
	uint descriptorCount;
}

struct VkDescriptorPoolCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkDescriptorPoolCreateFlags flags;
	uint maxSets;
	uint poolSizeCount;
	const(VkDescriptorPoolSize)* pPoolSizes;
}

struct VkDescriptorSetAllocateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkDescriptorPool descriptorPool;
	uint descriptorSetCount;
	const(VkDescriptorSetLayout)* pSetLayouts;
}

struct VkDescriptorImageInfo {
	VkSampler sampler;
	VkImageView imageView;
	VkImageLayout imageLayout;
}

struct VkDescriptorBufferInfo {
	VkBuffer buffer;
	VkDeviceSize offset;
	VkDeviceSize range;
}

struct VkWriteDescriptorSet {
	VkStructureType sType;
	const(void)* pNext;
	VkDescriptorSet dstSet;
	uint dstBinding;
	uint dstArrayElement;
	uint descriptorCount;
	VkDescriptorType descriptorType;
	const(VkDescriptorImageInfo)* pImageInfo;
	const(VkDescriptorBufferInfo)* pBufferInfo;
	const(VkBufferView)* pTexelBufferView;
}

struct VkCopyDescriptorSet {
	VkStructureType sType;
	const(void)* pNext;
	VkDescriptorSet srcSet;
	uint srcBinding;
	uint srcArrayElement;
	VkDescriptorSet dstSet;
	uint dstBinding;
	uint dstArrayElement;
	uint descriptorCount;
}

struct VkFramebufferCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkFramebufferCreateFlags flags;
	VkRenderPass renderPass;
	uint attachmentCount;
	const(VkImageView)* pAttachments;
	uint width;
	uint height;
	uint layers;
}

struct VkAttachmentDescription {
	VkAttachmentDescriptionFlags flags;
	VkFormat format;
	VkSampleCountFlagBits samples;
	VkAttachmentLoadOp loadOp;
	VkAttachmentStoreOp storeOp;
	VkAttachmentLoadOp stencilLoadOp;
	VkAttachmentStoreOp stencilStoreOp;
	VkImageLayout initialLayout;
	VkImageLayout finalLayout;
}

struct VkAttachmentReference {
	uint attachment;
	VkImageLayout layout;
}

struct VkSubpassDescription {
	VkSubpassDescriptionFlags flags;
	VkPipelineBindPoint pipelineBindPoint;
	uint inputAttachmentCount;
	const(VkAttachmentReference)* pInputAttachments;
	uint colorAttachmentCount;
	const(VkAttachmentReference)* pColorAttachments;
	const(VkAttachmentReference)* pResolveAttachments;
	const(VkAttachmentReference)* pDepthStencilAttachment;
	uint preserveAttachmentCount;
	const(uint)* pPreserveAttachments;
}

struct VkSubpassDependency {
	uint srcSubpass;
	uint dstSubpass;
	VkPipelineStageFlags srcStageMask;
	VkPipelineStageFlags dstStageMask;
	VkAccessFlags srcAccessMask;
	VkAccessFlags dstAccessMask;
	VkDependencyFlags dependencyFlags;
}

struct VkRenderPassCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkRenderPassCreateFlags flags;
	uint attachmentCount;
	const(VkAttachmentDescription)* pAttachments;
	uint subpassCount;
	const(VkSubpassDescription)* pSubpasses;
	uint dependencyCount;
	const(VkSubpassDependency)* pDependencies;
}

struct VkCommandPoolCreateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkCommandPoolCreateFlags flags;
	uint queueFamilyIndex;
}

struct VkCommandBufferAllocateInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkCommandPool commandPool;
	VkCommandBufferLevel level;
	uint commandBufferCount;
}

struct VkCommandBufferInheritanceInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkRenderPass renderPass;
	uint subpass;
	VkFramebuffer framebuffer;
	VkBool32 occlusionQueryEnable;
	VkQueryControlFlags queryFlags;
	VkQueryPipelineStatisticFlags pipelineStatistics;
}

struct VkCommandBufferBeginInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkCommandBufferUsageFlags flags;
	const(VkCommandBufferInheritanceInfo)* pInheritanceInfo;
}

struct VkBufferCopy {
	VkDeviceSize srcOffset;
	VkDeviceSize dstOffset;
	VkDeviceSize size;
}

struct VkImageSubresourceLayers {
	VkImageAspectFlags aspectMask;
	uint mipLevel;
	uint baseArrayLayer;
	uint layerCount;
}

struct VkImageCopy {
	VkImageSubresourceLayers srcSubresource;
	VkOffset3D srcOffset;
	VkImageSubresourceLayers dstSubresource;
	VkOffset3D dstOffset;
	VkExtent3D extent;
}

struct VkImageBlit {
	VkImageSubresourceLayers srcSubresource;
	VkOffset3D[2] srcOffsets;
	VkImageSubresourceLayers dstSubresource;
	VkOffset3D[2] dstOffsets;
}

struct VkBufferImageCopy {
	VkDeviceSize bufferOffset;
	uint bufferRowLength;
	uint bufferImageHeight;
	VkImageSubresourceLayers imageSubresource;
	VkOffset3D imageOffset;
	VkExtent3D imageExtent;
}

union VkClearColorValue {
	float[4] float32;
	int[4] int32;
	uint[4] uint32;
}

struct VkClearDepthStencilValue {
	float depth;
	uint stencil;
}

union VkClearValue {
	VkClearColorValue color;
	VkClearDepthStencilValue depthStencil;
}

struct VkClearAttachment {
	VkImageAspectFlags aspectMask;
	uint colorAttachment;
	VkClearValue clearValue;
}

struct VkClearRect {
	VkRect2D rect;
	uint baseArrayLayer;
	uint layerCount;
}

struct VkImageResolve {
	VkImageSubresourceLayers srcSubresource;
	VkOffset3D srcOffset;
	VkImageSubresourceLayers dstSubresource;
	VkOffset3D dstOffset;
	VkExtent3D extent;
}

struct VkMemoryBarrier {
	VkStructureType sType;
	const(void)* pNext;
	VkAccessFlags srcAccessMask;
	VkAccessFlags dstAccessMask;
}

struct VkBufferMemoryBarrier {
	VkStructureType sType;
	const(void)* pNext;
	VkAccessFlags srcAccessMask;
	VkAccessFlags dstAccessMask;
	uint srcQueueFamilyIndex;
	uint dstQueueFamilyIndex;
	VkBuffer buffer;
	VkDeviceSize offset;
	VkDeviceSize size;
}

struct VkImageMemoryBarrier {
	VkStructureType sType;
	const(void)* pNext;
	VkAccessFlags srcAccessMask;
	VkAccessFlags dstAccessMask;
	VkImageLayout oldLayout;
	VkImageLayout newLayout;
	uint srcQueueFamilyIndex;
	uint dstQueueFamilyIndex;
	VkImage image;
	VkImageSubresourceRange subresourceRange;
}

struct VkRenderPassBeginInfo {
	VkStructureType sType;
	const(void)* pNext;
	VkRenderPass renderPass;
	VkFramebuffer framebuffer;
	VkRect2D renderArea;
	uint clearValueCount;
	const(VkClearValue)* pClearValues;
}

struct VkDispatchIndirectCommand {
	uint x;
	uint y;
	uint z;
}

struct VkDrawIndexedIndirectCommand {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int vertexOffset;
	uint firstInstance;
}

struct VkDrawIndirectCommand {
	uint vertexCount;
	uint instanceCount;
	uint firstVertex;
	uint firstInstance;
}

alias PFN_vkCreateInstance = nothrow VkResult function(const(VkInstanceCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkInstance* pInstance);
alias PFN_vkDestroyInstance = nothrow void function(VkInstance instance, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkEnumeratePhysicalDevices = nothrow VkResult function(VkInstance instance, uint* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
alias PFN_vkGetPhysicalDeviceFeatures = nothrow void function(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
alias PFN_vkGetPhysicalDeviceFormatProperties = nothrow void function(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
alias PFN_vkGetPhysicalDeviceImageFormatProperties = nothrow VkResult function(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
alias PFN_vkGetPhysicalDeviceProperties = nothrow void function(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
alias PFN_vkGetPhysicalDeviceQueueFamilyProperties = nothrow void function(VkPhysicalDevice physicalDevice, uint* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
alias PFN_vkGetPhysicalDeviceMemoryProperties = nothrow void function(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
alias PFN_vkGetInstanceProcAddr = nothrow PFN_vkVoidFunction function(VkInstance instance, const(char)* pName);
alias PFN_vkGetDeviceProcAddr = nothrow PFN_vkVoidFunction function(VkDevice device, const(char)* pName);
alias PFN_vkCreateDevice = nothrow VkResult function(VkPhysicalDevice physicalDevice, const(VkDeviceCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDevice* pDevice);
alias PFN_vkDestroyDevice = nothrow void function(VkDevice device, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkEnumerateInstanceExtensionProperties = nothrow VkResult function(const(char)* pLayerName, uint* pPropertyCount, VkExtensionProperties* pProperties);
alias PFN_vkEnumerateDeviceExtensionProperties = nothrow VkResult function(VkPhysicalDevice physicalDevice, const(char)* pLayerName, uint* pPropertyCount, VkExtensionProperties* pProperties);
alias PFN_vkEnumerateInstanceLayerProperties = nothrow VkResult function(uint* pPropertyCount, VkLayerProperties* pProperties);
alias PFN_vkEnumerateDeviceLayerProperties = nothrow VkResult function(VkPhysicalDevice physicalDevice, uint* pPropertyCount, VkLayerProperties* pProperties);
alias PFN_vkGetDeviceQueue = nothrow void function(VkDevice device, uint queueFamilyIndex, uint queueIndex, VkQueue* pQueue);
alias PFN_vkQueueSubmit = nothrow VkResult function(VkQueue queue, uint submitCount, const(VkSubmitInfo)* pSubmits, VkFence fence);
alias PFN_vkQueueWaitIdle = nothrow VkResult function(VkQueue queue);
alias PFN_vkDeviceWaitIdle = nothrow VkResult function(VkDevice device);
alias PFN_vkAllocateMemory = nothrow VkResult function(VkDevice device, const(VkMemoryAllocateInfo)* pAllocateInfo, const(VkAllocationCallbacks)* pAllocator, VkDeviceMemory* pMemory);
alias PFN_vkFreeMemory = nothrow void function(VkDevice device, VkDeviceMemory memory, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkMapMemory = nothrow VkResult function(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);
alias PFN_vkUnmapMemory = nothrow void function(VkDevice device, VkDeviceMemory memory);
alias PFN_vkFlushMappedMemoryRanges = nothrow VkResult function(VkDevice device, uint memoryRangeCount, const(VkMappedMemoryRange)* pMemoryRanges);
alias PFN_vkInvalidateMappedMemoryRanges = nothrow VkResult function(VkDevice device, uint memoryRangeCount, const(VkMappedMemoryRange)* pMemoryRanges);
alias PFN_vkGetDeviceMemoryCommitment = nothrow void function(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
alias PFN_vkBindBufferMemory = nothrow VkResult function(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
alias PFN_vkBindImageMemory = nothrow VkResult function(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
alias PFN_vkGetBufferMemoryRequirements = nothrow void function(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
alias PFN_vkGetImageMemoryRequirements = nothrow void function(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
alias PFN_vkGetImageSparseMemoryRequirements = nothrow void function(VkDevice device, VkImage image, uint* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
alias PFN_vkGetPhysicalDeviceSparseImageFormatProperties = nothrow void function(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint* pPropertyCount, VkSparseImageFormatProperties* pProperties);
alias PFN_vkQueueBindSparse = nothrow VkResult function(VkQueue queue, uint bindInfoCount, const(VkBindSparseInfo)* pBindInfo, VkFence fence);
alias PFN_vkCreateFence = nothrow VkResult function(VkDevice device, const(VkFenceCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkFence* pFence);
alias PFN_vkDestroyFence = nothrow void function(VkDevice device, VkFence fence, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkResetFences = nothrow VkResult function(VkDevice device, uint fenceCount, const(VkFence)* pFences);
alias PFN_vkGetFenceStatus = nothrow VkResult function(VkDevice device, VkFence fence);
alias PFN_vkWaitForFences = nothrow VkResult function(VkDevice device, uint fenceCount, const(VkFence)* pFences, VkBool32 waitAll, ulong timeout);
alias PFN_vkCreateSemaphore = nothrow VkResult function(VkDevice device, const(VkSemaphoreCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSemaphore* pSemaphore);
alias PFN_vkDestroySemaphore = nothrow void function(VkDevice device, VkSemaphore semaphore, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreateEvent = nothrow VkResult function(VkDevice device, const(VkEventCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkEvent* pEvent);
alias PFN_vkDestroyEvent = nothrow void function(VkDevice device, VkEvent event, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkGetEventStatus = nothrow VkResult function(VkDevice device, VkEvent event);
alias PFN_vkSetEvent = nothrow VkResult function(VkDevice device, VkEvent event);
alias PFN_vkResetEvent = nothrow VkResult function(VkDevice device, VkEvent event);
alias PFN_vkCreateQueryPool = nothrow VkResult function(VkDevice device, const(VkQueryPoolCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkQueryPool* pQueryPool);
alias PFN_vkDestroyQueryPool = nothrow void function(VkDevice device, VkQueryPool queryPool, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkGetQueryPoolResults = nothrow VkResult function(VkDevice device, VkQueryPool queryPool, uint firstQuery, uint queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
alias PFN_vkCreateBuffer = nothrow VkResult function(VkDevice device, const(VkBufferCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkBuffer* pBuffer);
alias PFN_vkDestroyBuffer = nothrow void function(VkDevice device, VkBuffer buffer, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreateBufferView = nothrow VkResult function(VkDevice device, const(VkBufferViewCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkBufferView* pView);
alias PFN_vkDestroyBufferView = nothrow void function(VkDevice device, VkBufferView bufferView, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreateImage = nothrow VkResult function(VkDevice device, const(VkImageCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkImage* pImage);
alias PFN_vkDestroyImage = nothrow void function(VkDevice device, VkImage image, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkGetImageSubresourceLayout = nothrow void function(VkDevice device, VkImage image, const(VkImageSubresource)* pSubresource, VkSubresourceLayout* pLayout);
alias PFN_vkCreateImageView = nothrow VkResult function(VkDevice device, const(VkImageViewCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkImageView* pView);
alias PFN_vkDestroyImageView = nothrow void function(VkDevice device, VkImageView imageView, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreateShaderModule = nothrow VkResult function(VkDevice device, const(VkShaderModuleCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkShaderModule* pShaderModule);
alias PFN_vkDestroyShaderModule = nothrow void function(VkDevice device, VkShaderModule shaderModule, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreatePipelineCache = nothrow VkResult function(VkDevice device, const(VkPipelineCacheCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkPipelineCache* pPipelineCache);
alias PFN_vkDestroyPipelineCache = nothrow void function(VkDevice device, VkPipelineCache pipelineCache, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkGetPipelineCacheData = nothrow VkResult function(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
alias PFN_vkMergePipelineCaches = nothrow VkResult function(VkDevice device, VkPipelineCache dstCache, uint srcCacheCount, const(VkPipelineCache)* pSrcCaches);
alias PFN_vkCreateGraphicsPipelines = nothrow VkResult function(VkDevice device, VkPipelineCache pipelineCache, uint createInfoCount, const(VkGraphicsPipelineCreateInfo)* pCreateInfos, const(VkAllocationCallbacks)* pAllocator, VkPipeline* pPipelines);
alias PFN_vkCreateComputePipelines = nothrow VkResult function(VkDevice device, VkPipelineCache pipelineCache, uint createInfoCount, const(VkComputePipelineCreateInfo)* pCreateInfos, const(VkAllocationCallbacks)* pAllocator, VkPipeline* pPipelines);
alias PFN_vkDestroyPipeline = nothrow void function(VkDevice device, VkPipeline pipeline, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreatePipelineLayout = nothrow VkResult function(VkDevice device, const(VkPipelineLayoutCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkPipelineLayout* pPipelineLayout);
alias PFN_vkDestroyPipelineLayout = nothrow void function(VkDevice device, VkPipelineLayout pipelineLayout, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreateSampler = nothrow VkResult function(VkDevice device, const(VkSamplerCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSampler* pSampler);
alias PFN_vkDestroySampler = nothrow void function(VkDevice device, VkSampler sampler, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreateDescriptorSetLayout = nothrow VkResult function(VkDevice device, const(VkDescriptorSetLayoutCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDescriptorSetLayout* pSetLayout);
alias PFN_vkDestroyDescriptorSetLayout = nothrow void function(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreateDescriptorPool = nothrow VkResult function(VkDevice device, const(VkDescriptorPoolCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDescriptorPool* pDescriptorPool);
alias PFN_vkDestroyDescriptorPool = nothrow void function(VkDevice device, VkDescriptorPool descriptorPool, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkResetDescriptorPool = nothrow VkResult function(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
alias PFN_vkAllocateDescriptorSets = nothrow VkResult function(VkDevice device, const(VkDescriptorSetAllocateInfo)* pAllocateInfo, VkDescriptorSet* pDescriptorSets);
alias PFN_vkFreeDescriptorSets = nothrow VkResult function(VkDevice device, VkDescriptorPool descriptorPool, uint descriptorSetCount, const(VkDescriptorSet)* pDescriptorSets);
alias PFN_vkUpdateDescriptorSets = nothrow void function(VkDevice device, uint descriptorWriteCount, const(VkWriteDescriptorSet)* pDescriptorWrites, uint descriptorCopyCount, const(VkCopyDescriptorSet)* pDescriptorCopies);
alias PFN_vkCreateFramebuffer = nothrow VkResult function(VkDevice device, const(VkFramebufferCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkFramebuffer* pFramebuffer);
alias PFN_vkDestroyFramebuffer = nothrow void function(VkDevice device, VkFramebuffer framebuffer, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkCreateRenderPass = nothrow VkResult function(VkDevice device, const(VkRenderPassCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkRenderPass* pRenderPass);
alias PFN_vkDestroyRenderPass = nothrow void function(VkDevice device, VkRenderPass renderPass, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkGetRenderAreaGranularity = nothrow void function(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
alias PFN_vkCreateCommandPool = nothrow VkResult function(VkDevice device, const(VkCommandPoolCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkCommandPool* pCommandPool);
alias PFN_vkDestroyCommandPool = nothrow void function(VkDevice device, VkCommandPool commandPool, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkResetCommandPool = nothrow VkResult function(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
alias PFN_vkAllocateCommandBuffers = nothrow VkResult function(VkDevice device, const(VkCommandBufferAllocateInfo)* pAllocateInfo, VkCommandBuffer* pCommandBuffers);
alias PFN_vkFreeCommandBuffers = nothrow void function(VkDevice device, VkCommandPool commandPool, uint commandBufferCount, const(VkCommandBuffer)* pCommandBuffers);
alias PFN_vkBeginCommandBuffer = nothrow VkResult function(VkCommandBuffer commandBuffer, const(VkCommandBufferBeginInfo)* pBeginInfo);
alias PFN_vkEndCommandBuffer = nothrow VkResult function(VkCommandBuffer commandBuffer);
alias PFN_vkResetCommandBuffer = nothrow VkResult function(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
alias PFN_vkCmdBindPipeline = nothrow void function(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
alias PFN_vkCmdSetViewport = nothrow void function(VkCommandBuffer commandBuffer, uint firstViewport, uint viewportCount, const(VkViewport)* pViewports);
alias PFN_vkCmdSetScissor = nothrow void function(VkCommandBuffer commandBuffer, uint firstScissor, uint scissorCount, const(VkRect2D)* pScissors);
alias PFN_vkCmdSetLineWidth = nothrow void function(VkCommandBuffer commandBuffer, float lineWidth);
alias PFN_vkCmdSetDepthBias = nothrow void function(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
alias PFN_vkCmdSetBlendConstants = nothrow void function(VkCommandBuffer commandBuffer, const(float)[4] blendConstants);
alias PFN_vkCmdSetDepthBounds = nothrow void function(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
alias PFN_vkCmdSetStencilCompareMask = nothrow void function(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint compareMask);
alias PFN_vkCmdSetStencilWriteMask = nothrow void function(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint writeMask);
alias PFN_vkCmdSetStencilReference = nothrow void function(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint reference);
alias PFN_vkCmdBindDescriptorSets = nothrow void function(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint firstSet, uint descriptorSetCount, const(VkDescriptorSet)* pDescriptorSets, uint dynamicOffsetCount, const(uint)* pDynamicOffsets);
alias PFN_vkCmdBindIndexBuffer = nothrow void function(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
alias PFN_vkCmdBindVertexBuffers = nothrow void function(VkCommandBuffer commandBuffer, uint firstBinding, uint bindingCount, const(VkBuffer)* pBuffers, const(VkDeviceSize)* pOffsets);
alias PFN_vkCmdDraw = nothrow void function(VkCommandBuffer commandBuffer, uint vertexCount, uint instanceCount, uint firstVertex, uint firstInstance);
alias PFN_vkCmdDrawIndexed = nothrow void function(VkCommandBuffer commandBuffer, uint indexCount, uint instanceCount, uint firstIndex, int vertexOffset, uint firstInstance);
alias PFN_vkCmdDrawIndirect = nothrow void function(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint drawCount, uint stride);
alias PFN_vkCmdDrawIndexedIndirect = nothrow void function(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint drawCount, uint stride);
alias PFN_vkCmdDispatch = nothrow void function(VkCommandBuffer commandBuffer, uint x, uint y, uint z);
alias PFN_vkCmdDispatchIndirect = nothrow void function(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
alias PFN_vkCmdCopyBuffer = nothrow void function(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint regionCount, const(VkBufferCopy)* pRegions);
alias PFN_vkCmdCopyImage = nothrow void function(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint regionCount, const(VkImageCopy)* pRegions);
alias PFN_vkCmdBlitImage = nothrow void function(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint regionCount, const(VkImageBlit)* pRegions, VkFilter filter);
alias PFN_vkCmdCopyBufferToImage = nothrow void function(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint regionCount, const(VkBufferImageCopy)* pRegions);
alias PFN_vkCmdCopyImageToBuffer = nothrow void function(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint regionCount, const(VkBufferImageCopy)* pRegions);
alias PFN_vkCmdUpdateBuffer = nothrow void function(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const(uint)* pData);
alias PFN_vkCmdFillBuffer = nothrow void function(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint data);
alias PFN_vkCmdClearColorImage = nothrow void function(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const(VkClearColorValue)* pColor, uint rangeCount, const(VkImageSubresourceRange)* pRanges);
alias PFN_vkCmdClearDepthStencilImage = nothrow void function(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const(VkClearDepthStencilValue)* pDepthStencil, uint rangeCount, const(VkImageSubresourceRange)* pRanges);
alias PFN_vkCmdClearAttachments = nothrow void function(VkCommandBuffer commandBuffer, uint attachmentCount, const(VkClearAttachment)* pAttachments, uint rectCount, const(VkClearRect)* pRects);
alias PFN_vkCmdResolveImage = nothrow void function(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint regionCount, const(VkImageResolve)* pRegions);
alias PFN_vkCmdSetEvent = nothrow void function(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
alias PFN_vkCmdResetEvent = nothrow void function(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
alias PFN_vkCmdWaitEvents = nothrow void function(VkCommandBuffer commandBuffer, uint eventCount, const(VkEvent)* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint memoryBarrierCount, const(VkMemoryBarrier)* pMemoryBarriers, uint bufferMemoryBarrierCount, const(VkBufferMemoryBarrier)* pBufferMemoryBarriers, uint imageMemoryBarrierCount, const(VkImageMemoryBarrier)* pImageMemoryBarriers);
alias PFN_vkCmdPipelineBarrier = nothrow void function(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint memoryBarrierCount, const(VkMemoryBarrier)* pMemoryBarriers, uint bufferMemoryBarrierCount, const(VkBufferMemoryBarrier)* pBufferMemoryBarriers, uint imageMemoryBarrierCount, const(VkImageMemoryBarrier)* pImageMemoryBarriers);
alias PFN_vkCmdBeginQuery = nothrow void function(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint query, VkQueryControlFlags flags);
alias PFN_vkCmdEndQuery = nothrow void function(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint query);
alias PFN_vkCmdResetQueryPool = nothrow void function(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint firstQuery, uint queryCount);
alias PFN_vkCmdWriteTimestamp = nothrow void function(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint query);
alias PFN_vkCmdCopyQueryPoolResults = nothrow void function(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint firstQuery, uint queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
alias PFN_vkCmdPushConstants = nothrow void function(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint offset, uint size, const(void)* pValues);
alias PFN_vkCmdBeginRenderPass = nothrow void function(VkCommandBuffer commandBuffer, const(VkRenderPassBeginInfo)* pRenderPassBegin, VkSubpassContents contents);
alias PFN_vkCmdNextSubpass = nothrow void function(VkCommandBuffer commandBuffer, VkSubpassContents contents);
alias PFN_vkCmdEndRenderPass = nothrow void function(VkCommandBuffer commandBuffer);
alias PFN_vkCmdExecuteCommands = nothrow void function(VkCommandBuffer commandBuffer, uint commandBufferCount, const(VkCommandBuffer)* pCommandBuffers);

version (none) {
	VkResult vkCreateInstance(const(VkInstanceCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkInstance* pInstance);

	void vkDestroyInstance(VkInstance instance, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkEnumeratePhysicalDevices(VkInstance instance, uint* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);

	void vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);

	void vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);

	VkResult vkGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);

	void vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);

	void vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);

	void vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);

	PFN_vkVoidFunction vkGetInstanceProcAddr(VkInstance instance, const(char)* pName);

	PFN_vkVoidFunction vkGetDeviceProcAddr(VkDevice device, const(char)* pName);

	VkResult vkCreateDevice(VkPhysicalDevice physicalDevice, const(VkDeviceCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDevice* pDevice);

	void vkDestroyDevice(VkDevice device, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkEnumerateInstanceExtensionProperties(const(char)* pLayerName, uint* pPropertyCount, VkExtensionProperties* pProperties);

	VkResult vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const(char)* pLayerName, uint* pPropertyCount, VkExtensionProperties* pProperties);

	VkResult vkEnumerateInstanceLayerProperties(uint* pPropertyCount, VkLayerProperties* pProperties);

	VkResult vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint* pPropertyCount, VkLayerProperties* pProperties);

	void vkGetDeviceQueue(VkDevice device, uint queueFamilyIndex, uint queueIndex, VkQueue* pQueue);

	VkResult vkQueueSubmit(VkQueue queue, uint submitCount, const(VkSubmitInfo)* pSubmits, VkFence fence);

	VkResult vkQueueWaitIdle(VkQueue queue);

	VkResult vkDeviceWaitIdle(VkDevice device);

	VkResult vkAllocateMemory(VkDevice device, const(VkMemoryAllocateInfo)* pAllocateInfo, const(VkAllocationCallbacks)* pAllocator, VkDeviceMemory* pMemory);

	void vkFreeMemory(VkDevice device, VkDeviceMemory memory, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);

	void vkUnmapMemory(VkDevice device, VkDeviceMemory memory);

	VkResult vkFlushMappedMemoryRanges(VkDevice device, uint memoryRangeCount, const(VkMappedMemoryRange)* pMemoryRanges);

	VkResult vkInvalidateMappedMemoryRanges(VkDevice device, uint memoryRangeCount, const(VkMappedMemoryRange)* pMemoryRanges);

	void vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);

	VkResult vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);

	VkResult vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);

	void vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);

	void vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);

	void vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);

	void vkGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint* pPropertyCount, VkSparseImageFormatProperties* pProperties);

	VkResult vkQueueBindSparse(VkQueue queue, uint bindInfoCount, const(VkBindSparseInfo)* pBindInfo, VkFence fence);

	VkResult vkCreateFence(VkDevice device, const(VkFenceCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkFence* pFence);

	void vkDestroyFence(VkDevice device, VkFence fence, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkResetFences(VkDevice device, uint fenceCount, const(VkFence)* pFences);

	VkResult vkGetFenceStatus(VkDevice device, VkFence fence);

	VkResult vkWaitForFences(VkDevice device, uint fenceCount, const(VkFence)* pFences, VkBool32 waitAll, ulong timeout);

	VkResult vkCreateSemaphore(VkDevice device, const(VkSemaphoreCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSemaphore* pSemaphore);

	void vkDestroySemaphore(VkDevice device, VkSemaphore semaphore, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreateEvent(VkDevice device, const(VkEventCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkEvent* pEvent);

	void vkDestroyEvent(VkDevice device, VkEvent event, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkGetEventStatus(VkDevice device, VkEvent event);

	VkResult vkSetEvent(VkDevice device, VkEvent event);

	VkResult vkResetEvent(VkDevice device, VkEvent event);

	VkResult vkCreateQueryPool(VkDevice device, const(VkQueryPoolCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkQueryPool* pQueryPool);

	void vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint firstQuery, uint queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);

	VkResult vkCreateBuffer(VkDevice device, const(VkBufferCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkBuffer* pBuffer);

	void vkDestroyBuffer(VkDevice device, VkBuffer buffer, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreateBufferView(VkDevice device, const(VkBufferViewCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkBufferView* pView);

	void vkDestroyBufferView(VkDevice device, VkBufferView bufferView, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreateImage(VkDevice device, const(VkImageCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkImage* pImage);

	void vkDestroyImage(VkDevice device, VkImage image, const(VkAllocationCallbacks)* pAllocator);

	void vkGetImageSubresourceLayout(VkDevice device, VkImage image, const(VkImageSubresource)* pSubresource, VkSubresourceLayout* pLayout);

	VkResult vkCreateImageView(VkDevice device, const(VkImageViewCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkImageView* pView);

	void vkDestroyImageView(VkDevice device, VkImageView imageView, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreateShaderModule(VkDevice device, const(VkShaderModuleCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkShaderModule* pShaderModule);

	void vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreatePipelineCache(VkDevice device, const(VkPipelineCacheCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkPipelineCache* pPipelineCache);

	void vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);

	VkResult vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint srcCacheCount, const(VkPipelineCache)* pSrcCaches);

	VkResult vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint createInfoCount, const(VkGraphicsPipelineCreateInfo)* pCreateInfos, const(VkAllocationCallbacks)* pAllocator, VkPipeline* pPipelines);

	VkResult vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint createInfoCount, const(VkComputePipelineCreateInfo)* pCreateInfos, const(VkAllocationCallbacks)* pAllocator, VkPipeline* pPipelines);

	void vkDestroyPipeline(VkDevice device, VkPipeline pipeline, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreatePipelineLayout(VkDevice device, const(VkPipelineLayoutCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkPipelineLayout* pPipelineLayout);

	void vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreateSampler(VkDevice device, const(VkSamplerCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSampler* pSampler);

	void vkDestroySampler(VkDevice device, VkSampler sampler, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreateDescriptorSetLayout(VkDevice device, const(VkDescriptorSetLayoutCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDescriptorSetLayout* pSetLayout);

	void vkDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreateDescriptorPool(VkDevice device, const(VkDescriptorPoolCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDescriptorPool* pDescriptorPool);

	void vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);

	VkResult vkAllocateDescriptorSets(VkDevice device, const(VkDescriptorSetAllocateInfo)* pAllocateInfo, VkDescriptorSet* pDescriptorSets);

	VkResult vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint descriptorSetCount, const(VkDescriptorSet)* pDescriptorSets);

	void vkUpdateDescriptorSets(VkDevice device, uint descriptorWriteCount, const(VkWriteDescriptorSet)* pDescriptorWrites, uint descriptorCopyCount, const(VkCopyDescriptorSet)* pDescriptorCopies);

	VkResult vkCreateFramebuffer(VkDevice device, const(VkFramebufferCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkFramebuffer* pFramebuffer);

	void vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkCreateRenderPass(VkDevice device, const(VkRenderPassCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkRenderPass* pRenderPass);

	void vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass, const(VkAllocationCallbacks)* pAllocator);

	void vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);

	VkResult vkCreateCommandPool(VkDevice device, const(VkCommandPoolCreateInfo)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkCommandPool* pCommandPool);

	void vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);

	VkResult vkAllocateCommandBuffers(VkDevice device, const(VkCommandBufferAllocateInfo)* pAllocateInfo, VkCommandBuffer* pCommandBuffers);

	void vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint commandBufferCount, const(VkCommandBuffer)* pCommandBuffers);

	VkResult vkBeginCommandBuffer(VkCommandBuffer commandBuffer, const(VkCommandBufferBeginInfo)* pBeginInfo);

	VkResult vkEndCommandBuffer(VkCommandBuffer commandBuffer);

	VkResult vkResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);

	void vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);

	void vkCmdSetViewport(VkCommandBuffer commandBuffer, uint firstViewport, uint viewportCount, const(VkViewport)* pViewports);

	void vkCmdSetScissor(VkCommandBuffer commandBuffer, uint firstScissor, uint scissorCount, const(VkRect2D)* pScissors);

	void vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth);

	void vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);

	void vkCmdSetBlendConstants(VkCommandBuffer commandBuffer, const(float)[4] blendConstants);

	void vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);

	void vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint compareMask);

	void vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint writeMask);

	void vkCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint reference);

	void vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint firstSet, uint descriptorSetCount, const(VkDescriptorSet)* pDescriptorSets, uint dynamicOffsetCount, const(uint)* pDynamicOffsets);

	void vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);

	void vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint firstBinding, uint bindingCount, const(VkBuffer)* pBuffers, const(VkDeviceSize)* pOffsets);

	void vkCmdDraw(VkCommandBuffer commandBuffer, uint vertexCount, uint instanceCount, uint firstVertex, uint firstInstance);

	void vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint indexCount, uint instanceCount, uint firstIndex, int vertexOffset, uint firstInstance);

	void vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint drawCount, uint stride);

	void vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint drawCount, uint stride);

	void vkCmdDispatch(VkCommandBuffer commandBuffer, uint x, uint y, uint z);

	void vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);

	void vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint regionCount, const(VkBufferCopy)* pRegions);

	void vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint regionCount, const(VkImageCopy)* pRegions);

	void vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint regionCount, const(VkImageBlit)* pRegions, VkFilter filter);

	void vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint regionCount, const(VkBufferImageCopy)* pRegions);

	void vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint regionCount, const(VkBufferImageCopy)* pRegions);

	void vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const(uint)* pData);

	void vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint data);

	void vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const(VkClearColorValue)* pColor, uint rangeCount, const(VkImageSubresourceRange)* pRanges);

	void vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const(VkClearDepthStencilValue)* pDepthStencil, uint rangeCount, const(VkImageSubresourceRange)* pRanges);

	void vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint attachmentCount, const(VkClearAttachment)* pAttachments, uint rectCount, const(VkClearRect)* pRects);

	void vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint regionCount, const(VkImageResolve)* pRegions);

	void vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);

	void vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);

	void vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint eventCount, const(VkEvent)* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint memoryBarrierCount, const(VkMemoryBarrier)* pMemoryBarriers, uint bufferMemoryBarrierCount, const(VkBufferMemoryBarrier)* pBufferMemoryBarriers, uint imageMemoryBarrierCount, const(VkImageMemoryBarrier)* pImageMemoryBarriers);

	void vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint memoryBarrierCount, const(VkMemoryBarrier)* pMemoryBarriers, uint bufferMemoryBarrierCount, const(VkBufferMemoryBarrier)* pBufferMemoryBarriers, uint imageMemoryBarrierCount, const(VkImageMemoryBarrier)* pImageMemoryBarriers);

	void vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint query, VkQueryControlFlags flags);

	void vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint query);

	void vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint firstQuery, uint queryCount);

	void vkCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint query);

	void vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint firstQuery, uint queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);

	void vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint offset, uint size, const(void)* pValues);

	void vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, const(VkRenderPassBeginInfo)* pRenderPassBegin, VkSubpassContents contents);

	void vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents);

	void vkCmdEndRenderPass(VkCommandBuffer commandBuffer);

	void vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint commandBufferCount, const(VkCommandBuffer)* pCommandBuffers);
}

enum VK_KHR_surface = 1;
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkSurfaceKHR"));

enum VK_KHR_SURFACE_SPEC_VERSION = 25;
enum VK_KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface";

enum VkColorSpaceKHR {
	VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0,
	VK_COLORSPACE_BEGIN_RANGE = VK_COLORSPACE_SRGB_NONLINEAR_KHR,
	VK_COLORSPACE_END_RANGE = VK_COLORSPACE_SRGB_NONLINEAR_KHR,
	VK_COLORSPACE_RANGE_SIZE = (VK_COLORSPACE_SRGB_NONLINEAR_KHR - VK_COLORSPACE_SRGB_NONLINEAR_KHR + 1),
	VK_COLORSPACE_MAX_ENUM = 0x7FFFFFFF
}

enum VkPresentModeKHR {
	VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
	VK_PRESENT_MODE_MAILBOX_KHR = 1,
	VK_PRESENT_MODE_FIFO_KHR = 2,
	VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
	VK_PRESENT_MODE_BEGIN_RANGE = VK_PRESENT_MODE_IMMEDIATE_KHR,
	VK_PRESENT_MODE_END_RANGE = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
	VK_PRESENT_MODE_RANGE_SIZE = (VK_PRESENT_MODE_FIFO_RELAXED_KHR - VK_PRESENT_MODE_IMMEDIATE_KHR + 1),
	VK_PRESENT_MODE_MAX_ENUM = 0x7FFFFFFF
}

enum VkSurfaceTransformFlagBitsKHR {
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
}

alias VkSurfaceTransformFlagsKHR = VkFlags;

enum VkCompositeAlphaFlagBitsKHR {
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
}

alias VkCompositeAlphaFlagsKHR = VkFlags;

struct VkSurfaceCapabilitiesKHR {
	uint minImageCount;
	uint maxImageCount;
	VkExtent2D currentExtent;
	VkExtent2D minImageExtent;
	VkExtent2D maxImageExtent;
	uint maxImageArrayLayers;
	VkSurfaceTransformFlagsKHR supportedTransforms;
	VkSurfaceTransformFlagBitsKHR currentTransform;
	VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
	VkImageUsageFlags supportedUsageFlags;
}

struct VkSurfaceFormatKHR {
	VkFormat format;
	VkColorSpaceKHR colorSpace;
}

alias PFN_vkDestroySurfaceKHR = nothrow void function(VkInstance instance, VkSurfaceKHR surface, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkGetPhysicalDeviceSurfaceSupportKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, uint queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
alias PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
alias PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
alias PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint* pPresentModeCount, VkPresentModeKHR* pPresentModes);

version (none) {
	void vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);

	VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);

	VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);

	VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint* pPresentModeCount, VkPresentModeKHR* pPresentModes);
}

enum VK_KHR_swapchain = 1;
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkSwapchainKHR"));

enum VK_KHR_SWAPCHAIN_SPEC_VERSION = 67;
enum VK_KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain";

alias VkSwapchainCreateFlagsKHR = VkFlags;

struct VkSwapchainCreateInfoKHR {
	VkStructureType sType;
	const(void)* pNext;
	VkSwapchainCreateFlagsKHR flags;
	VkSurfaceKHR surface;
	uint minImageCount;
	VkFormat imageFormat;
	VkColorSpaceKHR imageColorSpace;
	VkExtent2D imageExtent;
	uint imageArrayLayers;
	VkImageUsageFlags imageUsage;
	VkSharingMode imageSharingMode;
	uint queueFamilyIndexCount;
	const(uint)* pQueueFamilyIndices;
	VkSurfaceTransformFlagBitsKHR preTransform;
	VkCompositeAlphaFlagBitsKHR compositeAlpha;
	VkPresentModeKHR presentMode;
	VkBool32 clipped;
	VkSwapchainKHR oldSwapchain;
}

struct VkPresentInfoKHR {
	VkStructureType sType;
	const(void)* pNext;
	uint waitSemaphoreCount;
	const(VkSemaphore)* pWaitSemaphores;
	uint swapchainCount;
	const(VkSwapchainKHR)* pSwapchains;
	const(uint)* pImageIndices;
	VkResult* pResults;
}

alias PFN_vkCreateSwapchainKHR = nothrow VkResult function(VkDevice device, const(VkSwapchainCreateInfoKHR)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSwapchainKHR* pSwapchain);
alias PFN_vkDestroySwapchainKHR = nothrow void function(VkDevice device, VkSwapchainKHR swapchain, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkGetSwapchainImagesKHR = nothrow VkResult function(VkDevice device, VkSwapchainKHR swapchain, uint* pSwapchainImageCount, VkImage* pSwapchainImages);
alias PFN_vkAcquireNextImageKHR = nothrow VkResult function(VkDevice device, VkSwapchainKHR swapchain, ulong timeout, VkSemaphore semaphore, VkFence fence, uint* pImageIndex);
alias PFN_vkQueuePresentKHR = nothrow VkResult function(VkQueue queue, const(VkPresentInfoKHR)* pPresentInfo);

version (none) {
	VkResult vkCreateSwapchainKHR(VkDevice device, const(VkSwapchainCreateInfoKHR)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSwapchainKHR* pSwapchain);

	void vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const(VkAllocationCallbacks)* pAllocator);

	VkResult vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint* pSwapchainImageCount, VkImage* pSwapchainImages);

	VkResult vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, ulong timeout, VkSemaphore semaphore, VkFence fence, uint* pImageIndex);

	VkResult vkQueuePresentKHR(VkQueue queue, const(VkPresentInfoKHR)* pPresentInfo);
}

enum VK_KHR_display = 1;
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDisplayKHR"));
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDisplayModeKHR"));

enum VK_KHR_DISPLAY_SPEC_VERSION = 21;
enum VK_KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display";

enum VkDisplayPlaneAlphaFlagBitsKHR {
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
}

alias VkDisplayModeCreateFlagsKHR = VkFlags;
alias VkDisplayPlaneAlphaFlagsKHR = VkFlags;
alias VkDisplaySurfaceCreateFlagsKHR = VkFlags;

struct VkDisplayPropertiesKHR {
	VkDisplayKHR display;
	const(char)* displayName;
	VkExtent2D physicalDimensions;
	VkExtent2D physicalResolution;
	VkSurfaceTransformFlagsKHR supportedTransforms;
	VkBool32 planeReorderPossible;
	VkBool32 persistentContent;
}

struct VkDisplayModeParametersKHR {
	VkExtent2D visibleRegion;
	uint refreshRate;
}

struct VkDisplayModePropertiesKHR {
	VkDisplayModeKHR displayMode;
	VkDisplayModeParametersKHR parameters;
}

struct VkDisplayModeCreateInfoKHR {
	VkStructureType sType;
	const(void)* pNext;
	VkDisplayModeCreateFlagsKHR flags;
	VkDisplayModeParametersKHR parameters;
}

struct VkDisplayPlaneCapabilitiesKHR {
	VkDisplayPlaneAlphaFlagsKHR supportedAlpha;
	VkOffset2D minSrcPosition;
	VkOffset2D maxSrcPosition;
	VkExtent2D minSrcExtent;
	VkExtent2D maxSrcExtent;
	VkOffset2D minDstPosition;
	VkOffset2D maxDstPosition;
	VkExtent2D minDstExtent;
	VkExtent2D maxDstExtent;
}

struct VkDisplayPlanePropertiesKHR {
	VkDisplayKHR currentDisplay;
	uint currentStackIndex;
}

struct VkDisplaySurfaceCreateInfoKHR {
	VkStructureType sType;
	const(void)* pNext;
	VkDisplaySurfaceCreateFlagsKHR flags;
	VkDisplayModeKHR displayMode;
	uint planeIndex;
	uint planeStackIndex;
	VkSurfaceTransformFlagBitsKHR transform;
	float globalAlpha;
	VkDisplayPlaneAlphaFlagBitsKHR alphaMode;
	VkExtent2D imageExtent;
}

alias PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, uint* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
alias PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, uint* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
alias PFN_vkGetDisplayPlaneSupportedDisplaysKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, uint planeIndex, uint* pDisplayCount, VkDisplayKHR* pDisplays);
alias PFN_vkGetDisplayModePropertiesKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
alias PFN_vkCreateDisplayModeKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const(VkDisplayModeCreateInfoKHR)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDisplayModeKHR* pMode);
alias PFN_vkGetDisplayPlaneCapabilitiesKHR = nothrow VkResult function(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
alias PFN_vkCreateDisplayPlaneSurfaceKHR = nothrow VkResult function(VkInstance instance, const(VkDisplaySurfaceCreateInfoKHR)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSurfaceKHR* pSurface);

version (none) {
	VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint* pPropertyCount, VkDisplayPropertiesKHR* pProperties);

	VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);

	VkResult vkGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint planeIndex, uint* pDisplayCount, VkDisplayKHR* pDisplays);

	VkResult vkGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);

	VkResult vkCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const(VkDisplayModeCreateInfoKHR)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDisplayModeKHR* pMode);

	VkResult vkGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);

	VkResult vkCreateDisplayPlaneSurfaceKHR(VkInstance instance, const(VkDisplaySurfaceCreateInfoKHR)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSurfaceKHR* pSurface);
}

enum VK_KHR_display_swapchain = 1;
enum VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 9;
enum VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain";

struct VkDisplayPresentInfoKHR {
	VkStructureType sType;
	const(void)* pNext;
	VkRect2D srcRect;
	VkRect2D dstRect;
	VkBool32 persistent;
}

alias PFN_vkCreateSharedSwapchainsKHR = nothrow VkResult function(VkDevice device, uint swapchainCount, const(VkSwapchainCreateInfoKHR)* pCreateInfos, const(VkAllocationCallbacks)* pAllocator, VkSwapchainKHR* pSwapchains);

version (none) {
	VkResult vkCreateSharedSwapchainsKHR(VkDevice device, uint swapchainCount, const(VkSwapchainCreateInfoKHR)* pCreateInfos, const(VkAllocationCallbacks)* pAllocator, VkSwapchainKHR* pSwapchains);
}

enum VK_EXT_debug_report = 1;
mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDebugReportCallbackEXT"));

enum VK_EXT_DEBUG_REPORT_SPEC_VERSION = 1;
enum VK_EXT_DEBUG_REPORT_EXTENSION_NAME = "VK_EXT_debug_report";

enum VkDebugReportObjectTypeEXT {
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
}

enum VkDebugReportErrorEXT {
	VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
	VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
}

enum VkDebugReportFlagBitsEXT {
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
	VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
	VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
	VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
}

alias VkDebugReportFlagsEXT = VkFlags;

alias PFN_vkDebugReportCallbackEXT = nothrow VkBool32 function(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, ulong object, size_t location, int messageCode, const(char)* pLayerPrefix, const(char)* pMessage, void* pUserData);

struct VkDebugReportCallbackCreateInfoEXT {
	VkStructureType sType;
	const(void)* pNext;
	VkDebugReportFlagsEXT flags;
	PFN_vkDebugReportCallbackEXT pfnCallback;
	void* pUserData;
}

alias PFN_vkCreateDebugReportCallbackEXT = nothrow VkResult function(VkInstance instance, const(VkDebugReportCallbackCreateInfoEXT)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDebugReportCallbackEXT* pCallback);
alias PFN_vkDestroyDebugReportCallbackEXT = nothrow void function(VkInstance instance, VkDebugReportCallbackEXT callback, const(VkAllocationCallbacks)* pAllocator);
alias PFN_vkDebugReportMessageEXT = nothrow void function(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, ulong object, size_t location, int messageCode, const(char)* pLayerPrefix, const(char)* pMessage);

version (none) {
	VkResult vkCreateDebugReportCallbackEXT(VkInstance instance, const(VkDebugReportCallbackCreateInfoEXT)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkDebugReportCallbackEXT* pCallback);

	void vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const(VkAllocationCallbacks)* pAllocator);

	void vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, ulong object, size_t location, int messageCode, const(char)* pLayerPrefix, const(char)* pMessage);
}
